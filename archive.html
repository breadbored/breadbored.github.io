<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/3de91d017adb82b4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3de91d017adb82b4.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-cefafc4da0529542.js" defer=""></script><script src="/_next/static/chunks/main-02216dd25b6676c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ee898d3b301edd99.js" defer=""></script><script src="/_next/static/chunks/pages/archive-a151114ec6b6bf67.js" defer=""></script><script src="/_next/static/ZkiAaYzxdFcVkz_zb_kL2/_buildManifest.js" defer=""></script><script src="/_next/static/ZkiAaYzxdFcVkz_zb_kL2/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-width mx-auto mt-12"><div class="pb-12 pt-6 text-center bg-white"><marquee class="my-4" behavior="alternate">HTML Is My Passion</marquee><h1 class="text-4xl font-bold mb-2">bread.codes</h1><h3 class="text-xl mb-4">code stuff</h3><nav class="space-x-4 mb-8"><a class="hover:text-blue-600" href="/">Home</a><a class="hover:text-blue-600" href="/search">Search</a><a class="hover:text-blue-600" href="/about">About</a><a class="hover:text-blue-600" href="/archive">Archive</a></nav><div role="group" tabindex="0" aria-label="Audio player" class="rhap_container rhap_loop--on rhap_play-status--paused mb-4"><audio src="/assets/Linkin-Park-Numb.mp3" loop="" autoPlay="" preload="auto"></audio><div class="rhap_header">Linkin-Park-Numb.mp3</div><div class="rhap_main rhap_stacked"><div class="rhap_progress-section"><div id="rhap_current-time" class="rhap_time rhap_current-time">--:--</div><div class="rhap_progress-container" aria-label="Audio progress control" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0"><div class="rhap_progress-bar rhap_progress-bar-show-download"><div class="rhap_progress-indicator" style="left:0%"></div><div class="rhap_progress-filled" style="width:0%"></div></div></div><div class="rhap_time rhap_total-time">--:--</div></div><div class="rhap_controls-section"><div class="rhap_additional-controls"><button aria-label="Disable loop" class="rhap_button-clear rhap_repeat-button" type="button"><span></span></button></div><div class="rhap_main-controls"><button aria-label="Play" class="rhap_button-clear rhap_main-controls-button rhap_play-pause-button" type="button"><span></span></button></div><div class="rhap_volume-controls"><div class="rhap_volume-container"><button aria-label="Mute" type="button" class="rhap_button-clear rhap_volume-button"><span></span></button><div role="progressbar" aria-label="Volume control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="NaN" tabindex="0" class="rhap_volume-bar-area"><div class="rhap_volume-bar"><div class="rhap_volume-indicator" style="left:40.00%;transition-duration:0s"></div></div></div></div></div></div></div></div><main class="px-4"><div class="posts"><article class="border border-black m-2.5 p-4"><a class="block" href="/archive/gameboy-printer-with-a-rp2040-pi-pico-microcontroller"><h1 class="text-2xl font-bold mb-2">Gameboy Printer with a RP2040 (Pi Pico) Microcontroller</h1><div class="mb-4"><p class="text-gray-600">November 30, 2022</p></div></a><div class="prose max-w-none mb-4">## Table of Contents</div><a class="block" href="/archive/gameboy-printer-with-a-rp2040-pi-pico-microcontroller"><img alt="Read more" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline" style="color:transparent" src="/assets/more.gif"/></a></article><article class="border border-black m-2.5 p-4"><a class="block" href="/archive/how-to-interpolate-wind-data"><h1 class="text-2xl font-bold mb-2">How to interpolate wind data</h1><div class="mb-4"><p class="text-gray-600">March 8, 2022</p></div></a><div class="prose max-w-none mb-4">This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` &amp; `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it&#x27;s own stripped down `metal_stdlib` with apple branded alternatives such as `vec&lt;T, n&gt;` instead of `std::vector&lt;T&gt;`), etc.</div><a class="block" href="/archive/how-to-interpolate-wind-data"><img alt="Read more" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline" style="color:transparent" src="/assets/more.gif"/></a></article></div></main></div></div><footer class="page-width text-center py-4 space-y-4 mx-auto"><div><img alt="IE Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ie_logo.gif"/><img alt="Netscape Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ns_logo.gif"/><img alt="Notepad" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/notepad.gif"/></div><div><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/><a href="mailto:brad@bread.codes"><img alt="Email Me" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/emailme.gif"/></a><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/></div><div style="background-color:#f0f0f0"><p><b>Copyright Â© <!-- -->2025<!-- --> BreadCodes</b></p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Gameboy Printer with a RP2040 (Pi Pico) Microcontroller","date":"2022-12-01","slug":"gameboy-printer-with-a-rp2040-pi-pico-microcontroller","excerpt":"## Table of Contents","content":"## Table of Contents\n\n1. [The Project](#the-project)\n2. [The Serial Protocol](#the-serial-protocol)\n   1. [Definitions](#definitions)\n   2. [Diagrams](#diagrams)\n   3. [Pseudocode](#pseudocode)\n3. [The Gameboy Printer](#the-gameboy-printer)\n4. [Important Notes](#important-notes)\n\n\u003ciframe width=\"536\" height=\"301\" src=\"https://www.youtube.com/embed/EhVYzfLQQ70\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003ca href=\"https://www.patreon.com/bePatron?u=34519148\" data-patreon-widget-type=\"become-patron-button\"\u003eBecome a Patron!\u003c/a\u003e\u003cscript async src=\"https://c6.patreon.com/becomePatronButton.bundle.js\"\u003e\u003c/script\u003e\n\n## The Project\n\nThe objective is to document the Gameboy Printer, it's protocol, and the image format in a single source, and use that information to create a printer driver using a Raspberry Pi Pico.\n\nI originally did this project on the Arduino back in 2014 using a project that was already available, but I'm writing all of this from the ground up to better document, integrate into other Gameboy related projects, and of course bring the Gameboy Printer to the Pi family. The project I originally used was [davedarko/GBPrinter](https://github.com/davedarko/GBPrinter) that generated PHP page to handle generating some of the code, but more recently I found that someone forked that project to bring us the improved [octavifs/GBPrinter](https://github.com/octavifs/GBPrinter) that uses Go for generating images.\n\nThe Raspberry Pi company have now released a $4 ARM microcontroller, and I wanted this to be as cheap as possible for other people to try.\n\n## The Serial Protocol\n\nThe Gameboy Original/Color/Advance, and by extension the Gameboy Printer, use an SPI-esque protocol to talk to each other. SPI is avery simple synchronous protocol, involving only a TX (outbound data), RX (inbound data), CLK (clock), and the CS (chip select) which the gameboy does not use. The Gameboy excludes the CS pin as it only expects to have a single master device and a single slave device.\n\n### Definitions\n\n- Master\n  - The primary device that manages the interaction\n- Slave\n  - The device being controlled by the master\n- CLK\n  - Clock\n  - A signal that goes `HIGH` then `LOW` to let the slave know that the next piece of data is coming\n- TX\n  - Digital signal out from the master or slave device. Connects to the other device's RX.\n- RX\n  - Digital signal in to the master or slave device. Connects to the other device's TX.\n- CS\n  - Chip Select (unused)\n- GND\n  - Ground\n\n### Diagrams\n\nBelow is the Gameboy Color Cable pinout.\n\n```text\n    _________   1 -\u003e 5v*\n   / 1  2  3 \\  2 -\u003e RX\n  /           \\ 3 -\u003e CLK\n  |           | 4 -\u003e TX\n  |  4  5  6  | 5 -\u003e Reserved*\n  +-----------+ 6 -\u003e GND\n\n* means we do not need that pin\n```\n\nIt is important to test these pins with a voltmeter because the inner cable colors are rarely correctly colored on 3rd party cables, and sources that rely on color coded wires may cause damage to your microcontroller. When you use a voltmeter to identify the TX and RX pins, remember that the TX from one end is the RX for the other and vice versa. Below will hopefully clarify what I am saying:\n\n```text\n  Master        Slave\n  | TX ___   ___ TX |\n  |        \\/       |\n  |        /\\       |\n  | RX ---   --- RX |\n```\n\nEach clock cycle (HIGH/LOW or 1/0) only one bit of data is transferred. Data is sent and read on the rising edge of the clock; rising edge meaning the short Â±1 microsecond when the clock goes from LOW to HIGH. The following is an ASCII diagram from the oscilloscope where the number `162` (`0xA2` in hex or `10100010` in binary). The Gameboy has a clock speed of 8192 bits per second (8kb/s), which is 1KB/s or 1 bit every ~122Î¼s.\n\nBoth the master and slave can send and receive data at the same time. Once 8 bits have been sent/received they are processed as a byte.\n\n```\nClock: ^ denotes rising edge, * denotes falling edge\nTX: sending `10100010` in binary (`0xA2` in hex)\nRX: receiving `0b11001100` in binary (`0xCC` in hex)\n\n                       ââââââââââ\n    ââââââââââââââââââââ 1 byte ââââââââââââââââââââ\n       __    __    __    __    __    __    __    __\nCLK __/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\\n      ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *\n       __          __                      __\nTX  __/  \\________/  \\____________________/  \\______\n      1     0     1     0     0     0     1     0\n       __    __                __    __\nRX  __/  \\__/  \\______________/  \\__/  \\____________\n      1     1     0     0     1     1     0     0\n```\n\n### Pseudocode\n\nGenerally, the master would look like this pseudocode where it drives the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\n// 1 is HIGH, 0 is LOW\nstate clock_state = 1;\n\nint clock_speed = 8192;\n\nwhile (data_bit_position \u003c 8) {\n  // Flip the state to what we're about to process\n  clock_state = clock_state == 1 ? 0 : 1;\n  // Send the clock state to the Gameboy Printer cable\n  set_clock(clock_state);\n\n  // Send data on rising edge\n  if (clock_state == 1) {\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n\n  // 1,000,000Î¼s in a second\n  // Wait 1,000,000/clock_speed in microseconds to match the clock speed\n  // Divide it by 2 so that the rising edge and falling edge take place within one cycle period\n  sleep_us(1000000 / clock_speed / 2);\n}\n```\n\nAnd generally, the slave would look like this pseudocode where it waits for a state change from the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\nstate last_clock_state = 1;\n\nwhile (data_bit_position \u003c 8) {\n  state current_clock_state = get_clock();\n\n  // Send data on rising edge\n  if (current_clock_state == 1 \u0026\u0026 current_clock_state !== last_clock_state) {\n    last_clock_state = current_clock_state;\n\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n}\n```\n\nThat pseudocode should give you an idea about what we're working with here.\n\n### The Gameboy Printer\n\nHere's the thing, this is where it gets complicated. I'll try to break it down.\n\n#### Master to Slave\n\nMaster TX to Slave RX is described below\n\n##### Magic Bytes (2)\n\nThis is the simplest part of the protocol. It never changes. The first byte the master sends is always `0x88` and the second byte is always `0x33`. All this does is tell the printer we are here and that we are about to send something it needs to listen to. That's all!\n\n##### Command Byte (1)\n\nThis tells the printer what we want to do.\n\n### Important Notes\n\n#### Voltage Warnings\n\nThe Pico is not 5v tolerant and can only send and receive 3.3v. **_Do not hook the Pico directly to the Gameboy Printer._** There is a risk that a 5v signal to the Pico's serial pins will release [the magic smoke](https://en.wikipedia.org/wiki/Magic_smoke). The pi doesn't have any big capacitors so no smoke will be seen, but I think it is a lot scarier when it just silently dies and you don't know why.\n\nThe Gameboy Printer can only send and receive 5v, and won't read data from the 3.3v Pico as it doesn't seem to reach the minimum `HIGH` threshold the GBP is trying to read. This doesn't damage anything, but it's a major bummer.\n\nYou will need a 3.3v to 5v logic level shifter to safely transmit and receive data, which will avoid both of these issues.","categories":["retro-computing","microcontrollers"],"skeets":[]},{"title":"How to interpolate wind data","date":"2022-03-09","slug":"how-to-interpolate-wind-data","excerpt":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.","content":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.\n\nThis is meant to be a reference article for non-scientific projects. This article has been heavily simplified for performance and \"close enough\" approximations.\n\n## Interpolation\n\nIf you're here reading this, you probably know that _interpolation_ is used when you have a series of data, either through time or space, and you want to estimate the data between your data points. If Xâ=0, Yâ=0 and Xâ=2, Yâ=4, then Xâ=1 means Yâ probably equals 2. We can guess this because we can see the 2 values make up a line similar to Y=2X, or maybe it's Y=X^2. Who's to say? What's important is using the data we have around us to best-guess this.\n\n## Problem \u0026 Requirements before Interpolation\n\nMap Distortion and Scaling were unique to our project, however they may interest you in similar projects. These are not required for interpolation at all. These are for if you were planning on putting a view with an X/Y coordinate system on a map and these problems weren't handled for you.\n\n### Map Distortion\n\nOur data was given to us in a 2D space with an XY coordinate system, however it was not processed for distortion. To do that, I found these scary looking equations:\n\nx = R (Î» - Î»â)\n\ny = R ln(tan(Ï/4 + Î¸/2))\n\nKey points that hopefully help:\n\n- R is the radius of the given sphere (6378137.0 meters, according to the WGS 1984 semimajor axis. I don't know what this means, it's just important)\n\n- Î»â is the central meridian (for the Mercator projection as we're using, this is 0.0Ë longitude)\n\n- Î» is the longitude in degrees (for example: -79.876884Ë)\n\n- Î¸ is the latitude in degrees (for example: 32.808445Ë)\n\nThe following example is given in Metal and Python:\n\n#### Metal\n\n```c++\n// We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n// This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\nfloat2 longLatToXY(float2 coords) {\n    float radius = 6378137.0;\n    float centralMeridian = 0.0;\n    float pi_approx = 3.1415926;\n    float x = radius * (coords.x - centralMeridian);\n    float y = radius * log(tan((pi_approx / 4) + (coords.y / 2)));\n    // return in X/Y format, even though we passed in as LongLat\n    return float2(x, y);\n}\n```\n\n#### Python 3\n\n```python\nfrom numpy import log as ln\nfrom math import pi, tan\n\n# We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n# This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\ndef longLatToXY(long: float, lat: float):\n    radius = 6378137.0\n    centralMeridian = 0.0\n    x = radius * (long - centralMeridian)\n    y = radius * ln(tan((pi / 4) + (lat / 2)))\n    # return in X/Y tuple format, even though we passed in as LongLat\n    return (x, y)\n```\n\nIf that sucks, skip it for now. I did.\n\n### Map scaling\n\nMaps are scaled on an often used zoom level of 0 to ~23. 0 means the map is zoomed all the way out and a single pixel represents several hundred/thousand miles of land, while zoom level ~23 means you could zoom into a blade of grass. This scaling is exponential, and thankfully the math is super easy. If you were to overlay a view of a known size perfectly over the map, the math would be as follows to make the view scale with the map:\n\n`scale = 2^(zoom_level)`\n\nThat's it! Now for code examples.\n\n#### Metal\n\n```c++\nfloat getMapScale(float zoomLevel) {\n    return pow(2.0, zoomLevel);\n}\n\n// Some arbitrary view size that fits perfectly over the map\nfloat2 screenWidthHeight = float2(300.0, 100.0);\n// Some arbitrary zoom level I choose. Get this from your map software/library.\nfloat zoomLevel = 4.6;\n\nfloat2 screenScaledWidthHeight = screenWidthHeight * getMapScale(zoomLevel);\n```\n\n#### Python 3\n\n```python\ndef getMapScale(zoom_level: float):\n    return pow(2, zoom_level)\n\n# Some arbitrary view size that fits perfectly over the map\nscreenWidth = 300\nscreenHeight = 100\n# Some arbitrary zoom level I choose. Get this from your map software/library.\nzoom_level = 4.6\n\nscale = getMapScale(zoom_level)\nscreenScaledWidth = scale * screenWidth\nscreenScaledHeight = scale * screenHeight\n```\n\n### Bilinear Interpolation\n\nFinally, we are handling interpolation. I don't know the exact name for this method, but I do know it is a form of bilinear interpolation (with a twist) that I accidentally made but then later found a ResearchGate post - by an actual scientist with a degree - that did the same method but significantly better. So I just copied the scientist's version and claimed it as my own, as is the engineering way.\n\nMy method of Bilinear Interpolation is regular Linear Interpolation, but its used a few times to get the values on the X axis and the Y axis separately and then together. The purpose of using Bilinear Interpolation here is because if I pick a position at random from within the view (with my 2D data overlayed) it is not going to be a clean whole number (or will be a whole number not in my evenly spaced data), so I will not have data for it. If I picked point (63.829, 12.236) but I only had data for (63, 12), (64, 12), (63, 13), (64, 13), I'd need to find what the data would be without making the visual have hard edges (aka just taking the data from the closest point [64, 12] until it gets closer to another point, creating a square around each point). That would look terrible.\n\nThe first thing you need to do is have an angle in degrees (example: 270Ë). Radians work, I just don't want to explain how to do it in radians even though we're turning the angle into radians anyway. It's like 3am and I just want a drop-in method, sue me. If you want to turn your radians into degrees then do the following:\n\n`degrees = 180 / Ï`\n\nOnce you have your angle in degrees and a number value for your speed (miles per hour, kilometers per hour, meters per second, nautical miles per quarter-century, it doesn't matter, just get a number), we're going to break up our angle and speed into U/V values. U and V values are a way to flatten our circular angle into 2 sin/cosine lines that can be interpolated independently and rejoined. For that I have this code that might explain better:\n\n#### Metal\n\n```c++\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    float pi_approx = 3.1415926;\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n```\n\n#### Python 3\n\n```python\nfrom math import sin, cos, pi\n\ndef velocityToUVComponents(degrees: float, speed: float):\n    # To receive interpolatable rotational degrees, we must seperate the\n    # angle into it's U and V values. U and V are the values that would\n    # be graphed as X and Y values respectively\n    u = (-1 * speed) * sin(2 * pi * degrees / 360)\n    v = (-1 * speed) * cos(2 * pi * degrees / 360)\n    return (u, v)\n```\n\nand to go from UV values to degrees:\n\n#### Metal\n\n```c++\nfloat uvComponentstoVelocity(float2 uv) {\n    float pi_approx = 3.1415926;\n    // Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    // atan2(v, u) aka atan2(y, x) is the correct order\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n```\n\n#### Python 3\n\n```python\nfrom math import pi, atan2\n\ndef uvComponentsToVelocity(u: float, v: float):\n    # Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    # atan2(v, u) aka atan2(y, x) is the correct order for this use case. Don't ask why, I don't know.\n    return (atan2(v, u) * 360 / 2 / pi) + 180\n```\n\nAs I said, the purpose of this is to interpolate these U and V values independently of each other. As an added bonus, the returning angles when we're finally done with this will always be between 0-360 and wrap around appropriately. What's so special about that? Have you tried averaging 1Ë and 359Ë? It comes out to 180Ë instead of 0Ë or 360Ë, which is wrong. U and V values are also good if you want to find just the simple average between two angles, which is the first step of interpolation!\n\nBefore continuing, please note that in Metal I'm passing around a pointer to a 1D array (representing a flat 2D array for Swift\u003c-\u003eMetal compatibility) array of `WindGridPoint` values called `WindGridPoint *windGrid`. `WindGridPoint` is described below:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridPoint {\n    vector_float2 position;\n    float speed;\n    uint angle;\n};\n```\n\nThat is all the data I have for every point on the grid. Before I continue, I first want to mention that if you are following my example of passing around a 1D array representing a 2D array (not recommended but its easier), you need to know the size of the grid ahead of time or pass in another object like above called `WindGridInfo`:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridInfo {\n    uint width;\n    uint height;\n    uint screenWidth;\n    uint screenHeight;\n};\n```\n\nNow we can use this object to map over a 1D array as if it were a 2D array:\n\n#### Swift\n\n```swift\n// Renderer.swift\nlet info: WindGridInfo = WindGridInfo(\n    width: 300,     // number of data points on the X axis\n    height: 100,    // number of data points on the Y axis\n    screenWidth: self.view.currentDrawable.width,\n    screenHeight: self.view.currentDrawable.height\n)\n// Now pass this into your Metal pipeline\n```\n\n#### Metal\n\n```c++\n// Shaders.metal\n\nuint arr2DtoArr1D (uint x, uint y, WindGridInfo *info) {\n    return x + (y * info.width);\n}\n\n// A Vertex Pipeline that takes and executes our data from Swift. Can also be a Compute or any other pipeline type.\nvertex VertexOut vertexShader(\n  device Particle *particleArray [[buffer(0)]],\n  const device WindGridPoint *windGridPoints [[buffer(1)]],\n  const device WindGridInfo *windGridInfo [[buffer(2)]],\n  unsigned int vid [[vertex_id]]\n) {\n    // particleArray is our array of particles on the screen\n    // windGridPoints is the data for the grid\n    // * windGridInfo is what we just created that stores our grid information *\n    // vid is the index of the particleArray\n\n    WindGridInfo* info = windGridInfo;\n    uint dataPointX = 32;\n    uint dataPointY = 61;\n    uint dataPointIndex = arr2DtoArr1D(dataPointX, dataPointY, info);\n    WindGridPoint neededPoint = windGridPoints[dataPointIndex];\n}\n```\n\nThat's how I look up a data point from a properly ordered array!\n\nThe next step is described by the `getUVsOfRelativePosition` function below. What we are doing is making a square around the arbitrary point and getting the data from the 4 nearest points that create a square. For each of those points, we would use the `getUVsOfAbsolutePosition` function to get the data for that point. `getUVsOfAbsolutePosition` is using the method described above in regards to indexing a flattened 2D array.\n\nOne more note: I now use a float3 for UV values to include the speed as a z value. The \"degrees to UV code\" above has changed.\n\nThe full code for the bilinear interpolation functions for Metal, including the UV components, are below\n\n#### Metal\n\n```c++\n# define pi_approx 3.1415926\n\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n\nfloat uvComponentstoVelocity(float3 uvs) {\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n\nfloat3 getUVsOfAbsolutePosition(int2 position, const device WindGridPoint *windGrid) {\n    // Get UV of a known point\n    WindGridPoint data_point = windGrid[int(position.x) + (127 * int(position.y))];\n    float2 uv = velocityToUVComponents(data_point.angle - 90, data_point.speed);\n    return float3(uv.x, uv.y, data_point.speed);\n}\n\nfloat4x3 getUVsOfRelativePosition(float4 positions, const device WindGridPoint *windGrid) {\n    // Get the values of the surrounding 4 corner coordinates\n    // Values are returned as UV values, described in uvComponents function\n    int lowX = positions[0];\n    int lowY = positions[1];\n    int highX = positions[2];\n    int highY = positions[3];\n    float3 tl_uvs = getUVsOfAbsolutePosition(int2(lowX, lowY), windGrid);    // Top Left Coord;      Relative 0,0\n    float3 tr_uvs = getUVsOfAbsolutePosition(int2(highX, lowY), windGrid);    // Top Right Coord;     Relative 1,0\n    float3 bl_uvs = getUVsOfAbsolutePosition(int2(lowX, highY), windGrid);    // Bottom Left Coord;   Relative 0,1\n    float3 br_uvs = getUVsOfAbsolutePosition(int2(highX, highY), windGrid); // Bottom Right Coord;  Relative 1,1\n\n    return float4x3(tl_uvs, tr_uvs, bl_uvs, br_uvs);\n}\n\nfloat3 interpolateVelocity(float2 position, const device WindGridPoint *windGrid) {\n    // position is the adjusted position to fit the grid. X is 0-127, Y is 0-68\n\n    float lowX = floor(position.x);\n    float lowY = floor(position.y);\n    float highX = ceil(position.x);\n    float highY = ceil(position.y);\n\n    float4x3 uvs = getUVsOfRelativePosition(float4(lowX, lowY, highX, highY), windGrid);\n\n    float3 topLeftUVS = uvs[0];      // 0,0\n    float3 topRightUVS = uvs[1];     // 1,0\n    float3 bottomLeftUVS = uvs[2];   // 0,1\n    float3 bottomRightUVS = uvs[3];  // 1,1\n    const uint U = 0; // U value\n    const uint V = 1; // V value\n    const uint S = 2; // Speed value\n\n    // Interpolate U values\n    // x with y1\n    float lowerXU1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[U];\n    float lowerXU2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[U];\n    float lowerXU = lowerXU1 + lowerXU2;\n    // x with y2\n    float upperXU1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[U];\n    float upperXU2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[U];\n    float upperXU = upperXU1 + upperXU2;\n    // y with interpolated x\n    float yU1 = ((highY - position.y) / (highY - lowY)) * lowerXU;\n    float yU2 = ((position.y - highY) / (highY - lowY)) * upperXU;\n    float yU = yU1 + yU2;\n\n    // Repeat the same interpolation on the V values\n    // x with y1\n    float lowerXV1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[V];\n    float lowerXV2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[V];\n    float lowerXV = lowerXV1 + lowerXV2;\n    // x with y2\n    float upperXV1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[V];\n    float upperXV2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[V];\n    float upperXV = upperXV1 + upperXV2;\n    // y with interpolated x\n    float yV1 = ((highY - position.y) / (highY - lowY)) * lowerXV;\n    float yV2 = ((position.y - highY) / (highY - lowY)) * upperXV;\n    float yV = yV1 + yV2;\n\n    // Repeat the same interpolation on the Speed\n    // x with y1\n    float lowerXS1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[S];\n    float lowerXS2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[S];\n    float lowerXS = lowerXS1 + lowerXS2;\n    // x with y2\n    float upperXS1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[S];\n    float upperXS2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[S];\n    float upperXS = upperXS1 + upperXS2;\n    // y with interpolated x\n    float yS1 = ((highY - position.y) / (highY - lowY)) * lowerXS;\n    float yS2 = ((position.y - highY) / (highY - lowY)) * upperXS;\n    float yS = abs(yS1) + abs(yS2);\n\n    float3 resUVS = float3(yU, yV, yS);\n    float resultDirection = uvComponentstoVelocity(resUVS);\n    return float2(resultDirection, resUVS.z);\n}\n```\n\nNow we can just call `interpolateVelocity` with an arbitrary point within our grid and we have our rotation in degrees as our X and our speed as our Y.\n\n#### Metal\n\n```c++\n// Get these from the buffer:\nWindGridPoint* windGridPointArr = windGridPoints\nWindGridInfo* info = windGridInfo;\n\n// Separated for clarity\nfloat arbitraryX = 38.382921;\nfloat arbitraryY = 71.881391;\nfloat2 arbitraryPosition = float2(arbitraryX, arbitraryY);\nfloat2 directionAndSpeed = interpolateVelocity(arbitraryPosition, windGridPointArr);\nfloat directionInDegrees = directionAndSpeed.x;\nfloat speed = directionAndSpeed.y;\n```\n\nThat's it! Email me at [brad@bread.codes](mailto://brad@bread.codes) if you have any questions or want to raise concerns about the efficacy of my work.","categories":["data","algorithms"],"skeets":[]}]},"__N_SSG":true},"page":"/archive","query":{},"buildId":"ZkiAaYzxdFcVkz_zb_kL2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>