<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title></title><meta name="theme-color" content="#333333"/><meta name="title" content="bread.codes"/><meta name="author" content="BreadCodes"/><meta name="description" content="This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` &amp; `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it&#x27;s own stripped down `metal_stdlib` with apple branded alternatives such as `vec&lt;T, n&gt;` instead of `std::vector&lt;T&gt;`), etc."/><meta name="keywords" content="data, algorithms, bread.codes, breadcodes, breadbored, programming, engineering, software, engineering, development, blog, tech, technology, computer science, game boy, gameboy, game boy advance, GBA, gameboy advance, hacking, reverse engineering, reverse, engineering, pokemon, pokemon hacking, pokemon reverse engineering, nintendo hacking, nintendo reverse engineering, nintendo, gamefreak, game freak"/><meta name="google-adsense-account" content="ca-pub-8749505090904262"/><meta property="og:type" content="article"/><meta property="og:url" content="https://bread.codes/posts/how-to-interpolate-wind-data"/><meta property="og:title" content="How to interpolate wind data"/><meta property="og:description" content="This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` &amp; `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it&#x27;s own stripped down `metal_stdlib` with apple branded alternatives such as `vec&lt;T, n&gt;` instead of `std::vector&lt;T&gt;`), etc."/><meta property="og:image" content="https://bread.codes/og/how-to-interpolate-wind-data.png"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:site_name" content="bread.codes"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:url" content="https://bread.codes/posts/how-to-interpolate-wind-data"/><meta name="twitter:title" content="How to interpolate wind data"/><meta name="twitter:description" content="This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` &amp; `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it&#x27;s own stripped down `metal_stdlib` with apple branded alternatives such as `vec&lt;T, n&gt;` instead of `std::vector&lt;T&gt;`), etc."/><meta name="twitter:image" content="https://bread.codes/og/how-to-interpolate-wind-data.png"/><meta name="twitter:creator" content="@breadbored"/><meta name="next-head-count" content="23"/><link rel="preload" href="/_next/static/css/e200af822b218498.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e200af822b218498.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-cefafc4da0529542.js" defer=""></script><script src="/_next/static/chunks/main-7aaa19766eb4191a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a0b186ef086209bd.js" defer=""></script><script src="/_next/static/chunks/385-85646af490fd9012.js" defer=""></script><script src="/_next/static/chunks/770-5cf8662c33579acf.js" defer=""></script><script src="/_next/static/chunks/pages/archive/%5Bslug%5D-ee6d27487d4751f7.js" defer=""></script><script src="/_next/static/aWPEjUahS7LWqpd4h3kcq/_buildManifest.js" defer=""></script><script src="/_next/static/aWPEjUahS7LWqpd4h3kcq/_ssgManifest.js" defer=""></script></head><body><link rel="preload" as="image" href="/assets/accessibility_icon.png"/><div id="__next"><div style="position:fixed;bottom:10px;right:10px;display:flex;align-items:flex-end;gap:10px"><button type="button" aria-label="Toggle accessibility options" aria-expanded="false" aria-controls="accessibility-menu" title="Accessibility options" style="cursor:pointer;background:none;border:none;padding:0;flex-shrink:0"><img src="/assets/accessibility_icon.png" alt="" aria-hidden="true" style="width:64px;height:64px;margin:0 auto;padding:2px;border-radius:8px;border:2px solid white;background-color:white"/></button></div><div class="page-width   mx-auto mt-12"><div class="pb-12 pt-6 text-center bg-white"><a href="https://sendfox.com/bread" class="pb-4"><marquee behavior="alternate" class="pb-4">subscribe</marquee></a><h1 class="text-4xl font-bold mb-2 pixel-font-fancy">bread.codes</h1><h3 class="text-xl mb-4">code stuff</h3><nav class="space-x-4 mb-8"><a class="hover:text-blue-600 pixel-font" href="/">Home</a><a class="hover:text-blue-600 pixel-font" href="/series/">Series</a><a class="hover:text-blue-600 pixel-font" href="/about/">About</a><a class="hover:text-blue-600 pixel-font" href="/archive/">Archive</a></nav><div role="group" tabindex="0" aria-label="Audio player" class="rhap_container rhap_loop--on rhap_play-status--paused mb-4"><audio src="/assets/Linkin-Park-Numb.mp3" loop="" preload="auto"></audio><div class="rhap_header">Linkin-Park-Numb.mp3</div><div class="rhap_main rhap_stacked"><div class="rhap_progress-section"><div id="rhap_current-time" class="rhap_time rhap_current-time">--:--</div><div class="rhap_progress-container" aria-label="Audio progress control" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0"><div class="rhap_progress-bar rhap_progress-bar-show-download"><div class="rhap_progress-indicator" style="left:0%"></div><div class="rhap_progress-filled" style="width:0%"></div></div></div><div class="rhap_time rhap_total-time">--:--</div></div><div class="rhap_controls-section"><div class="rhap_additional-controls"><button aria-label="Disable loop" class="rhap_button-clear rhap_repeat-button" type="button"><span></span></button></div><div class="rhap_main-controls"><button aria-label="Play" class="rhap_button-clear rhap_main-controls-button rhap_play-pause-button" type="button"><span></span></button></div><div class="rhap_volume-controls"><div class="rhap_volume-container"><button aria-label="Mute" type="button" class="rhap_button-clear rhap_volume-button"><span></span></button><div role="progressbar" aria-label="Volume control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="NaN" tabindex="0" class="rhap_volume-bar-area"><div class="rhap_volume-bar"><div class="rhap_volume-indicator" style="left:40.00%;transition-duration:0s"></div></div></div></div></div></div></div></div><main class="px-4"><article class="max-w-2xl mx-auto px-4" style="background:white"><h1 class="text-4xl font-bold mb-4">How to interpolate wind data</h1><div class="mb-8 text-gray-600 pixel-font">March 8, 2022</div><div class="prose max-w-none text-center"><p>This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-<strong><em>like</em></strong> language and is missing many core features of C++11 such as <span id="new" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">new</span> &amp; <span id="delete" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">delete</span> operators, <span id="memalloc" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">memalloc</span>, <span id="memset" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">memset</span>, <span id="free" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">free</span>, inheritance/derived classes, the foundational <span id="stdlib" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">stdlib</span> (though it comes with it&#x27;s own stripped down <span id="metal-stdlib" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">metal_stdlib</span> with apple branded alternatives such as <span id="vec-t--n-" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">vec&lt;T, n&gt;</span> instead of <span id="std--vector-t-" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">std::vector&lt;T&gt;</span>), etc.</p>
<p>This is meant to be a reference article for non-scientific projects. This article has been heavily simplified for performance and &quot;close enough&quot; approximations.</p>
<h2 id="interpolation" class="heading-anchor-wrapper"><a href="#interpolation" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Interpolation<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h2>
<p>If you&#x27;re here reading this, you probably know that <em>interpolation</em> is used when you have a series of data, either through time or space, and you want to estimate the data between your data points. If X₀=0, Y₀=0 and X₂=2, Y₂=4, then X₁=1 means Y₁ probably equals 2. We can guess this because we can see the 2 values make up a line similar to Y=2X, or maybe it&#x27;s Y=X^2. Who&#x27;s to say? What&#x27;s important is using the data we have around us to best-guess this.</p>
<h2 id="problem---requirements-before-interpolation" class="heading-anchor-wrapper"><a href="#problem---requirements-before-interpolation" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Problem &amp; Requirements before Interpolation<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h2>
<p>Map Distortion and Scaling were unique to our project, however they may interest you in similar projects. These are not required for interpolation at all. These are for if you were planning on putting a view with an X/Y coordinate system on a map and these problems weren&#x27;t handled for you.</p>
<h3 id="map-distortion" class="heading-anchor-wrapper"><a href="#map-distortion" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Map Distortion<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h3>
<p>Our data was given to us in a 2D space with an XY coordinate system, however it was not processed for distortion. To do that, I found these scary looking equations:</p>
<p>x = R (λ - λ₀)</p>
<p>y = R ln(tan(π/4 + θ/2))</p>
<p>Key points that hopefully help:</p>
<ul>
<li>
<p>R is the radius of the given sphere (6378137.0 meters, according to the WGS 1984 semimajor axis. I don&#x27;t know what this means, it&#x27;s just important)</p>
</li>
<li>
<p>λ₀ is the central meridian (for the Mercator projection as we&#x27;re using, this is 0.0˚ longitude)</p>
</li>
<li>
<p>λ is the longitude in degrees (for example: -79.876884˚)</p>
</li>
<li>
<p>θ is the latitude in degrees (for example: 32.808445˚)</p>
</li>
</ul>
<p>The following example is given in Metal and Python:</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat-----this-is-important-for-gis--geojson--mapbox--google-maps--etc--float2-longlattoxy-float2-coords--------float-radius---6378137-0------float-centralmeridian---0-0------float-pi-approx---3-1415926------float-x---radius----coords-x---centralmeridian-------float-y---radius---log-tan--pi-approx---4-----coords-y---2------------return-in-x-y-format--even-though-we-passed-in-as-longlat-----return-float2-x--y------pre" class="not-prose"><code id="---we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat-----this-is-important-for-gis--geojson--mapbox--google-maps--etc--float2-longlattoxy-float2-coords--------float-radius---6378137-0------float-centralmeridian---0-0------float-pi-approx---3-1415926------float-x---radius----coords-x---centralmeridian-------float-y---radius---log-tan--pi-approx---4-----coords-y---2------------return-in-x-y-format--even-though-we-passed-in-as-longlat-----return-float2-x--y-----"><pre id="---we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat-----this-is-important-for-gis--geojson--mapbox--google-maps--etc--float2-longlattoxy-float2-coords--------float-radius---6378137-0------float-centralmeridian---0-0------float-pi-approx---3-1415926------float-x---radius----coords-x---centralmeridian-------float-y---radius---log-tan--pi-approx---4-----coords-y---2------------return-in-x-y-format--even-though-we-passed-in-as-longlat-----return-float2-x--y------pre" class="not-prose"><code id="---we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat-----this-is-important-for-gis--geojson--mapbox--google-maps--etc--float2-longlattoxy-float2-coords--------float-radius---6378137-0------float-centralmeridian---0-0------float-pi-approx---3-1415926------float-x---radius----coords-x---centralmeridian-------float-y---radius---log-tan--pi-approx---4-----coords-y---2------------return-in-x-y-format--even-though-we-passed-in-as-longlat-----return-float2-x--y-----">// We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.
// This is important for GIS, GeoJSON, MapBox, Google Maps, etc.
float2 longLatToXY(float2 coords) {
    float radius = 6378137.0;
    float centralMeridian = 0.0;
    float pi_approx = 3.1415926;
    float x = radius * (coords.x - centralMeridian);
    float y = radius * log(tan((pi_approx / 4) + (coords.y / 2)));
    // return in X/Y format, even though we passed in as LongLat
    return float2(x, y);
}
</code></pre></code></pre>
<h4 id="python-3" class="heading-anchor-wrapper"><a href="#python-3" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Python 3<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="from-numpy-import-log-as-ln-from-math-import-pi--tan----we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat----this-is-important-for-gis--geojson--mapbox--google-maps--etc--def-longlattoxy-long--float--lat--float-------radius---6378137-0-----centralmeridian---0-0-----x---radius----long---centralmeridian------y---radius---ln-tan--pi---4-----lat---2----------return-in-x-y-tuple-format--even-though-we-passed-in-as-longlat-----return--x--y---pre" class="not-prose"><code id="from-numpy-import-log-as-ln-from-math-import-pi--tan----we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat----this-is-important-for-gis--geojson--mapbox--google-maps--etc--def-longlattoxy-long--float--lat--float-------radius---6378137-0-----centralmeridian---0-0-----x---radius----long---centralmeridian------y---radius---ln-tan--pi---4-----lat---2----------return-in-x-y-tuple-format--even-though-we-passed-in-as-longlat-----return--x--y--"><pre id="from-numpy-import-log-as-ln-from-math-import-pi--tan----we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat----this-is-important-for-gis--geojson--mapbox--google-maps--etc--def-longlattoxy-long--float--lat--float-------radius---6378137-0-----centralmeridian---0-0-----x---radius----long---centralmeridian------y---radius---ln-tan--pi---4-----lat---2----------return-in-x-y-tuple-format--even-though-we-passed-in-as-longlat-----return--x--y---pre" class="not-prose"><code id="from-numpy-import-log-as-ln-from-math-import-pi--tan----we-use-longlat--we-all-know-it-as-latlong--but-it-is-standard-in-math-and-mapping-to-use-longlat----this-is-important-for-gis--geojson--mapbox--google-maps--etc--def-longlattoxy-long--float--lat--float-------radius---6378137-0-----centralmeridian---0-0-----x---radius----long---centralmeridian------y---radius---ln-tan--pi---4-----lat---2----------return-in-x-y-tuple-format--even-though-we-passed-in-as-longlat-----return--x--y--">from numpy import log as ln
from math import pi, tan

# We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.
# This is important for GIS, GeoJSON, MapBox, Google Maps, etc.
def longLatToXY(long: float, lat: float):
    radius = 6378137.0
    centralMeridian = 0.0
    x = radius * (long - centralMeridian)
    y = radius * ln(tan((pi / 4) + (lat / 2)))
    # return in X/Y tuple format, even though we passed in as LongLat
    return (x, y)
</code></pre></code></pre>
<p>If that sucks, skip it for now. I did.</p>
<h3 id="map-scaling" class="heading-anchor-wrapper"><a href="#map-scaling" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Map scaling<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h3>
<p>Maps are scaled on an often used zoom level of 0 to ~23. 0 means the map is zoomed all the way out and a single pixel represents several hundred/thousand miles of land, while zoom level ~23 means you could zoom into a blade of grass. This scaling is exponential, and thankfully the math is super easy. If you were to overlay a view of a known size perfectly over the map, the math would be as follows to make the view scale with the map:</p>
<p><span id="scale---2--zoom-level-" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">scale = 2^(zoom_level)</span></p>
<p>That&#x27;s it! Now for code examples.</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="float-getmapscale-float-zoomlevel--------return-pow-2-0--zoomlevel---------some-arbitrary-view-size-that-fits-perfectly-over-the-map-float2-screenwidthheight---float2-300-0--100-0------some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--float-zoomlevel---4-6---float2-screenscaledwidthheight---screenwidthheight---getmapscale-zoomlevel----pre" class="not-prose"><code id="float-getmapscale-float-zoomlevel--------return-pow-2-0--zoomlevel---------some-arbitrary-view-size-that-fits-perfectly-over-the-map-float2-screenwidthheight---float2-300-0--100-0------some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--float-zoomlevel---4-6---float2-screenscaledwidthheight---screenwidthheight---getmapscale-zoomlevel---"><pre id="float-getmapscale-float-zoomlevel--------return-pow-2-0--zoomlevel---------some-arbitrary-view-size-that-fits-perfectly-over-the-map-float2-screenwidthheight---float2-300-0--100-0------some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--float-zoomlevel---4-6---float2-screenscaledwidthheight---screenwidthheight---getmapscale-zoomlevel----pre" class="not-prose"><code id="float-getmapscale-float-zoomlevel--------return-pow-2-0--zoomlevel---------some-arbitrary-view-size-that-fits-perfectly-over-the-map-float2-screenwidthheight---float2-300-0--100-0------some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--float-zoomlevel---4-6---float2-screenscaledwidthheight---screenwidthheight---getmapscale-zoomlevel---">float getMapScale(float zoomLevel) {
    return pow(2.0, zoomLevel);
}

// Some arbitrary view size that fits perfectly over the map
float2 screenWidthHeight = float2(300.0, 100.0);
// Some arbitrary zoom level I choose. Get this from your map software/library.
float zoomLevel = 4.6;

float2 screenScaledWidthHeight = screenWidthHeight * getMapScale(zoomLevel);
</code></pre></code></pre>
<h4 id="python-3" class="heading-anchor-wrapper"><a href="#python-3" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Python 3<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="def-getmapscale-zoom-level--float-------return-pow-2--zoom-level-----some-arbitrary-view-size-that-fits-perfectly-over-the-map-screenwidth---300-screenheight---100---some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--zoom-level---4-6--scale---getmapscale-zoom-level--screenscaledwidth---scale---screenwidth-screenscaledheight---scale---screenheight--pre" class="not-prose"><code id="def-getmapscale-zoom-level--float-------return-pow-2--zoom-level-----some-arbitrary-view-size-that-fits-perfectly-over-the-map-screenwidth---300-screenheight---100---some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--zoom-level---4-6--scale---getmapscale-zoom-level--screenscaledwidth---scale---screenwidth-screenscaledheight---scale---screenheight-"><pre id="def-getmapscale-zoom-level--float-------return-pow-2--zoom-level-----some-arbitrary-view-size-that-fits-perfectly-over-the-map-screenwidth---300-screenheight---100---some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--zoom-level---4-6--scale---getmapscale-zoom-level--screenscaledwidth---scale---screenwidth-screenscaledheight---scale---screenheight--pre" class="not-prose"><code id="def-getmapscale-zoom-level--float-------return-pow-2--zoom-level-----some-arbitrary-view-size-that-fits-perfectly-over-the-map-screenwidth---300-screenheight---100---some-arbitrary-zoom-level-i-choose--get-this-from-your-map-software-library--zoom-level---4-6--scale---getmapscale-zoom-level--screenscaledwidth---scale---screenwidth-screenscaledheight---scale---screenheight-">def getMapScale(zoom_level: float):
    return pow(2, zoom_level)

# Some arbitrary view size that fits perfectly over the map
screenWidth = 300
screenHeight = 100
# Some arbitrary zoom level I choose. Get this from your map software/library.
zoom_level = 4.6

scale = getMapScale(zoom_level)
screenScaledWidth = scale * screenWidth
screenScaledHeight = scale * screenHeight
</code></pre></code></pre>
<h3 id="bilinear-interpolation" class="heading-anchor-wrapper"><a href="#bilinear-interpolation" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Bilinear Interpolation<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h3>
<p>Finally, we are handling interpolation. I don&#x27;t know the exact name for this method, but I do know it is a form of bilinear interpolation (with a twist) that I accidentally made but then later found a ResearchGate post - by an actual scientist with a degree - that did the same method but significantly better. So I just copied the scientist&#x27;s version and claimed it as my own, as is the engineering way.</p>
<p>My method of Bilinear Interpolation is regular Linear Interpolation, but its used a few times to get the values on the X axis and the Y axis separately and then together. The purpose of using Bilinear Interpolation here is because if I pick a position at random from within the view (with my 2D data overlayed) it is not going to be a clean whole number (or will be a whole number not in my evenly spaced data), so I will not have data for it. If I picked point (63.829, 12.236) but I only had data for (63, 12), (64, 12), (63, 13), (64, 13), I&#x27;d need to find what the data would be without making the visual have hard edges (aka just taking the data from the closest point [64, 12] until it gets closer to another point, creating a square around each point). That would look terrible.</p>
<p>The first thing you need to do is have an angle in degrees (example: 270˚). Radians work, I just don&#x27;t want to explain how to do it in radians even though we&#x27;re turning the angle into radians anyway. It&#x27;s like 3am and I just want a drop-in method, sue me. If you want to turn your radians into degrees then do the following:</p>
<p><span id="degrees---180----" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">degrees = 180 / π</span></p>
<p>Once you have your angle in degrees and a number value for your speed (miles per hour, kilometers per hour, meters per second, nautical miles per quarter-century, it doesn&#x27;t matter, just get a number), we&#x27;re going to break up our angle and speed into U/V values. U and V values are a way to flatten our circular angle into 2 sin/cosine lines that can be interpolated independently and rejoined. For that I have this code that might explain better:</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="float2-velocitytouvcomponents-int-degrees--float-speed--------float-pi-approx---3-1415926---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------pre" class="not-prose"><code id="float2-velocitytouvcomponents-int-degrees--float-speed--------float-pi-approx---3-1415926---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v-----"><pre id="float2-velocitytouvcomponents-int-degrees--float-speed--------float-pi-approx---3-1415926---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------pre" class="not-prose"><code id="float2-velocitytouvcomponents-int-degrees--float-speed--------float-pi-approx---3-1415926---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v-----">float2 velocityToUVComponents(int degrees, float speed) {
    float pi_approx = 3.1415926;
    // To receive interpolatable rotational degrees, we must seperate the
    // angle into it&#x27;s U and V values. U and V are the values that would
    // be graphed as X and Y values respectively
    float u = -speed * sin(2 * pi_approx * degrees / 360);
    float v = -speed * cos(2 * pi_approx * degrees / 360);
    return float2(u,v);
}
</code></pre></code></pre>
<h4 id="python-3" class="heading-anchor-wrapper"><a href="#python-3" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Python 3<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="from-math-import-sin--cos--pi--def-velocitytouvcomponents-degrees--float--speed--float---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the-------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would-------be-graphed-as-x-and-y-values-respectively-----u-----1---speed----sin-2---pi---degrees---360------v-----1---speed----cos-2---pi---degrees---360------return--u--v---pre" class="not-prose"><code id="from-math-import-sin--cos--pi--def-velocitytouvcomponents-degrees--float--speed--float---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the-------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would-------be-graphed-as-x-and-y-values-respectively-----u-----1---speed----sin-2---pi---degrees---360------v-----1---speed----cos-2---pi---degrees---360------return--u--v--"><pre id="from-math-import-sin--cos--pi--def-velocitytouvcomponents-degrees--float--speed--float---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the-------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would-------be-graphed-as-x-and-y-values-respectively-----u-----1---speed----sin-2---pi---degrees---360------v-----1---speed----cos-2---pi---degrees---360------return--u--v---pre" class="not-prose"><code id="from-math-import-sin--cos--pi--def-velocitytouvcomponents-degrees--float--speed--float---------to-receive-interpolatable-rotational-degrees--we-must-seperate-the-------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would-------be-graphed-as-x-and-y-values-respectively-----u-----1---speed----sin-2---pi---degrees---360------v-----1---speed----cos-2---pi---degrees---360------return--u--v--">from math import sin, cos, pi

def velocityToUVComponents(degrees: float, speed: float):
    # To receive interpolatable rotational degrees, we must seperate the
    # angle into it&#x27;s U and V values. U and V are the values that would
    # be graphed as X and Y values respectively
    u = (-1 * speed) * sin(2 * pi * degrees / 360)
    v = (-1 * speed) * cos(2 * pi * degrees / 360)
    return (u, v)
</code></pre></code></pre>
<p>and to go from UV values to degrees:</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="float-uvcomponentstovelocity-float2-uv--------float-pi-approx---3-1415926---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y----------atan2-v--u--aka-atan2-y--x--is-the-correct-order-----return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----pre" class="not-prose"><code id="float-uvcomponentstovelocity-float2-uv--------float-pi-approx---3-1415926---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y----------atan2-v--u--aka-atan2-y--x--is-the-correct-order-----return--atan2-uvs-y--uvs-x----360---2---pi-approx----180----"><pre id="float-uvcomponentstovelocity-float2-uv--------float-pi-approx---3-1415926---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y----------atan2-v--u--aka-atan2-y--x--is-the-correct-order-----return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----pre" class="not-prose"><code id="float-uvcomponentstovelocity-float2-uv--------float-pi-approx---3-1415926---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y----------atan2-v--u--aka-atan2-y--x--is-the-correct-order-----return--atan2-uvs-y--uvs-x----360---2---pi-approx----180----">float uvComponentstoVelocity(float2 uv) {
    float pi_approx = 3.1415926;
    // Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).
    // atan2(v, u) aka atan2(y, x) is the correct order
    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;
}
</code></pre></code></pre>
<h4 id="python-3" class="heading-anchor-wrapper"><a href="#python-3" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Python 3<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="from-math-import-pi--atan2--def-uvcomponentstovelocity-u--float--v--float---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y---------atan2-v--u--aka-atan2-y--x--is-the-correct-order-for-this-use-case--don-t-ask-why--i-don-t-know------return--atan2-v--u----360---2---pi----180--pre" class="not-prose"><code id="from-math-import-pi--atan2--def-uvcomponentstovelocity-u--float--v--float---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y---------atan2-v--u--aka-atan2-y--x--is-the-correct-order-for-this-use-case--don-t-ask-why--i-don-t-know------return--atan2-v--u----360---2---pi----180-"><pre id="from-math-import-pi--atan2--def-uvcomponentstovelocity-u--float--v--float---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y---------atan2-v--u--aka-atan2-y--x--is-the-correct-order-for-this-use-case--don-t-ask-why--i-don-t-know------return--atan2-v--u----360---2---pi----180--pre" class="not-prose"><code id="from-math-import-pi--atan2--def-uvcomponentstovelocity-u--float--v--float---------despite-what-most-sources-will-tell-you-about-atan2--do-not-put-atan2-u--v--aka-atan2-x--y---------atan2-v--u--aka-atan2-y--x--is-the-correct-order-for-this-use-case--don-t-ask-why--i-don-t-know------return--atan2-v--u----360---2---pi----180-">from math import pi, atan2

def uvComponentsToVelocity(u: float, v: float):
    # Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).
    # atan2(v, u) aka atan2(y, x) is the correct order for this use case. Don&#x27;t ask why, I don&#x27;t know.
    return (atan2(v, u) * 360 / 2 / pi) + 180
</code></pre></code></pre>
<p>As I said, the purpose of this is to interpolate these U and V values independently of each other. As an added bonus, the returning angles when we&#x27;re finally done with this will always be between 0-360 and wrap around appropriately. What&#x27;s so special about that? Have you tried averaging 1˚ and 359˚? It comes out to 180˚ instead of 0˚ or 360˚, which is wrong. U and V values are also good if you want to find just the simple average between two angles, which is the first step of interpolation!</p>
<p>Before continuing, please note that in Metal I&#x27;m passing around a pointer to a 1D array (representing a flat 2D array for Swift&lt;-&gt;Metal compatibility) array of <span id="windgridpoint" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">WindGridPoint</span> values called <span id="windgridpoint--windgrid" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">WindGridPoint *windGrid</span>. <span id="windgridpoint" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">WindGridPoint</span> is described below:</p>
<h4 id="objective-c" class="heading-anchor-wrapper"><a href="#objective-c" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Objective-C<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridpoint-------vector-float2-position------float-speed------uint-angle------pre" class="not-prose"><code id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridpoint-------vector-float2-position------float-speed------uint-angle-----"><pre id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridpoint-------vector-float2-position------float-speed------uint-angle------pre" class="not-prose"><code id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridpoint-------vector-float2-position------float-speed------uint-angle-----">// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.
// You will need to add a simple Bridging-Header file to do this.
struct WindGridPoint {
    vector_float2 position;
    float speed;
    uint angle;
};
</code></pre></code></pre>
<p>That is all the data I have for every point on the grid. Before I continue, I first want to mention that if you are following my example of passing around a 1D array representing a 2D array (not recommended but its easier), you need to know the size of the grid ahead of time or pass in another object like above called <span id="windgridinfo" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">WindGridInfo</span>:</p>
<h4 id="objective-c" class="heading-anchor-wrapper"><a href="#objective-c" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Objective-C<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridinfo-------uint-width------uint-height------uint-screenwidth------uint-screenheight------pre" class="not-prose"><code id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridinfo-------uint-width------uint-height------uint-screenwidth------uint-screenheight-----"><pre id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridinfo-------uint-width------uint-height------uint-screenwidth------uint-screenheight------pre" class="not-prose"><code id="---this-is-in-an-objective-c-header---h--file-so-that-i-can-use-the-struct-in-both-swift-and-metal-----you-will-need-to-add-a-simple-bridging-header-file-to-do-this--struct-windgridinfo-------uint-width------uint-height------uint-screenwidth------uint-screenheight-----">// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.
// You will need to add a simple Bridging-Header file to do this.
struct WindGridInfo {
    uint width;
    uint height;
    uint screenWidth;
    uint screenHeight;
};
</code></pre></code></pre>
<p>Now we can use this object to map over a 1D array as if it were a 2D array:</p>
<h4 id="swift" class="heading-anchor-wrapper"><a href="#swift" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Swift<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---renderer-swift-let-info--windgridinfo---windgridinfo------width--300---------number-of-data-points-on-the-x-axis-----height--100--------number-of-data-points-on-the-y-axis-----screenwidth--self-view-currentdrawable-width------screenheight--self-view-currentdrawable-height------now-pass-this-into-your-metal-pipeline--pre" class="not-prose"><code id="---renderer-swift-let-info--windgridinfo---windgridinfo------width--300---------number-of-data-points-on-the-x-axis-----height--100--------number-of-data-points-on-the-y-axis-----screenwidth--self-view-currentdrawable-width------screenheight--self-view-currentdrawable-height------now-pass-this-into-your-metal-pipeline-"><pre id="---renderer-swift-let-info--windgridinfo---windgridinfo------width--300---------number-of-data-points-on-the-x-axis-----height--100--------number-of-data-points-on-the-y-axis-----screenwidth--self-view-currentdrawable-width------screenheight--self-view-currentdrawable-height------now-pass-this-into-your-metal-pipeline--pre" class="not-prose"><code id="---renderer-swift-let-info--windgridinfo---windgridinfo------width--300---------number-of-data-points-on-the-x-axis-----height--100--------number-of-data-points-on-the-y-axis-----screenwidth--self-view-currentdrawable-width------screenheight--self-view-currentdrawable-height------now-pass-this-into-your-metal-pipeline-">// Renderer.swift
let info: WindGridInfo = WindGridInfo(
    width: 300,     // number of data points on the X axis
    height: 100,    // number of data points on the Y axis
    screenWidth: self.view.currentDrawable.width,
    screenHeight: self.view.currentDrawable.height
)
// Now pass this into your Metal pipeline
</code></pre></code></pre>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---shaders-metal--uint-arr2dtoarr1d--uint-x--uint-y--windgridinfo--info--------return-x----y---info-width---------a-vertex-pipeline-that-takes-and-executes-our-data-from-swift--can-also-be-a-compute-or-any-other-pipeline-type--vertex-vertexout-vertexshader----device-particle--particlearray---buffer-0-------const-device-windgridpoint--windgridpoints---buffer-1-------const-device-windgridinfo--windgridinfo---buffer-2-------unsigned-int-vid---vertex-id--------------particlearray-is-our-array-of-particles-on-the-screen--------windgridpoints-is-the-data-for-the-grid----------windgridinfo-is-what-we-just-created-that-stores-our-grid-information----------vid-is-the-index-of-the-particlearray------windgridinfo--info---windgridinfo------uint-datapointx---32------uint-datapointy---61------uint-datapointindex---arr2dtoarr1d-datapointx--datapointy--info-------windgridpoint-neededpoint---windgridpoints-datapointindex------pre" class="not-prose"><code id="---shaders-metal--uint-arr2dtoarr1d--uint-x--uint-y--windgridinfo--info--------return-x----y---info-width---------a-vertex-pipeline-that-takes-and-executes-our-data-from-swift--can-also-be-a-compute-or-any-other-pipeline-type--vertex-vertexout-vertexshader----device-particle--particlearray---buffer-0-------const-device-windgridpoint--windgridpoints---buffer-1-------const-device-windgridinfo--windgridinfo---buffer-2-------unsigned-int-vid---vertex-id--------------particlearray-is-our-array-of-particles-on-the-screen--------windgridpoints-is-the-data-for-the-grid----------windgridinfo-is-what-we-just-created-that-stores-our-grid-information----------vid-is-the-index-of-the-particlearray------windgridinfo--info---windgridinfo------uint-datapointx---32------uint-datapointy---61------uint-datapointindex---arr2dtoarr1d-datapointx--datapointy--info-------windgridpoint-neededpoint---windgridpoints-datapointindex-----"><pre id="---shaders-metal--uint-arr2dtoarr1d--uint-x--uint-y--windgridinfo--info--------return-x----y---info-width---------a-vertex-pipeline-that-takes-and-executes-our-data-from-swift--can-also-be-a-compute-or-any-other-pipeline-type--vertex-vertexout-vertexshader----device-particle--particlearray---buffer-0-------const-device-windgridpoint--windgridpoints---buffer-1-------const-device-windgridinfo--windgridinfo---buffer-2-------unsigned-int-vid---vertex-id--------------particlearray-is-our-array-of-particles-on-the-screen--------windgridpoints-is-the-data-for-the-grid----------windgridinfo-is-what-we-just-created-that-stores-our-grid-information----------vid-is-the-index-of-the-particlearray------windgridinfo--info---windgridinfo------uint-datapointx---32------uint-datapointy---61------uint-datapointindex---arr2dtoarr1d-datapointx--datapointy--info-------windgridpoint-neededpoint---windgridpoints-datapointindex------pre" class="not-prose"><code id="---shaders-metal--uint-arr2dtoarr1d--uint-x--uint-y--windgridinfo--info--------return-x----y---info-width---------a-vertex-pipeline-that-takes-and-executes-our-data-from-swift--can-also-be-a-compute-or-any-other-pipeline-type--vertex-vertexout-vertexshader----device-particle--particlearray---buffer-0-------const-device-windgridpoint--windgridpoints---buffer-1-------const-device-windgridinfo--windgridinfo---buffer-2-------unsigned-int-vid---vertex-id--------------particlearray-is-our-array-of-particles-on-the-screen--------windgridpoints-is-the-data-for-the-grid----------windgridinfo-is-what-we-just-created-that-stores-our-grid-information----------vid-is-the-index-of-the-particlearray------windgridinfo--info---windgridinfo------uint-datapointx---32------uint-datapointy---61------uint-datapointindex---arr2dtoarr1d-datapointx--datapointy--info-------windgridpoint-neededpoint---windgridpoints-datapointindex-----">// Shaders.metal

uint arr2DtoArr1D (uint x, uint y, WindGridInfo *info) {
    return x + (y * info.width);
}

// A Vertex Pipeline that takes and executes our data from Swift. Can also be a Compute or any other pipeline type.
vertex VertexOut vertexShader(
  device Particle *particleArray [[buffer(0)]],
  const device WindGridPoint *windGridPoints [[buffer(1)]],
  const device WindGridInfo *windGridInfo [[buffer(2)]],
  unsigned int vid [[vertex_id]]
) {
    // particleArray is our array of particles on the screen
    // windGridPoints is the data for the grid
    // * windGridInfo is what we just created that stores our grid information *
    // vid is the index of the particleArray

    WindGridInfo* info = windGridInfo;
    uint dataPointX = 32;
    uint dataPointY = 61;
    uint dataPointIndex = arr2DtoArr1D(dataPointX, dataPointY, info);
    WindGridPoint neededPoint = windGridPoints[dataPointIndex];
}
</code></pre></code></pre>
<p>That&#x27;s how I look up a data point from a properly ordered array!</p>
<p>The next step is described by the <span id="getuvsofrelativeposition" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">getUVsOfRelativePosition</span> function below. What we are doing is making a square around the arbitrary point and getting the data from the 4 nearest points that create a square. For each of those points, we would use the <span id="getuvsofabsoluteposition" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">getUVsOfAbsolutePosition</span> function to get the data for that point. <span id="getuvsofabsoluteposition" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">getUVsOfAbsolutePosition</span> is using the method described above in regards to indexing a flattened 2D array.</p>
<p>One more note: I now use a float3 for UV values to include the speed as a z value. The &quot;degrees to UV code&quot; above has changed.</p>
<p>The full code for the bilinear interpolation functions for Metal, including the UV components, are below</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="--define-pi-approx-3-1415926--float2-velocitytouvcomponents-int-degrees--float-speed-----------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------float-uvcomponentstovelocity-float3-uvs--------return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----float3-getuvsofabsoluteposition-int2-position--const-device-windgridpoint--windgrid-----------get-uv-of-a-known-point-----windgridpoint-data-point---windgrid-int-position-x-----127---int-position-y---------float2-uv---velocitytouvcomponents-data-point-angle---90--data-point-speed-------return-float3-uv-x--uv-y--data-point-speed------float4x3-getuvsofrelativeposition-float4-positions--const-device-windgridpoint--windgrid-----------get-the-values-of-the-surrounding-4-corner-coordinates--------values-are-returned-as-uv-values--described-in-uvcomponents-function-----int-lowx---positions-0-------int-lowy---positions-1-------int-highx---positions-2-------int-highy---positions-3-------float3-tl-uvs---getuvsofabsoluteposition-int2-lowx--lowy---windgrid---------top-left-coord-------relative-0-0-----float3-tr-uvs---getuvsofabsoluteposition-int2-highx--lowy---windgrid---------top-right-coord------relative-1-0-----float3-bl-uvs---getuvsofabsoluteposition-int2-lowx--highy---windgrid---------bottom-left-coord----relative-0-1-----float3-br-uvs---getuvsofabsoluteposition-int2-highx--highy---windgrid------bottom-right-coord---relative-1-1------return-float4x3-tl-uvs--tr-uvs--bl-uvs--br-uvs------float3-interpolatevelocity-float2-position--const-device-windgridpoint--windgrid-----------position-is-the-adjusted-position-to-fit-the-grid--x-is-0-127--y-is-0-68------float-lowx---floor-position-x-------float-lowy---floor-position-y-------float-highx---ceil-position-x-------float-highy---ceil-position-y--------float4x3-uvs---getuvsofrelativeposition-float4-lowx--lowy--highx--highy---windgrid--------float3-topleftuvs---uvs-0-----------0-0-----float3-toprightuvs---uvs-1----------1-0-----float3-bottomleftuvs---uvs-2--------0-1-----float3-bottomrightuvs---uvs-3-------1-1-----const-uint-u---0-----u-value-----const-uint-v---1-----v-value-----const-uint-s---2-----speed-value---------interpolate-u-values--------x-with-y1-----float-lowerxu1-----highx---position-x-----highx---lowx-----topleftuvs-u-------float-lowerxu2-----position-x---lowx-----highx---lowx-----toprightuvs-u-------float-lowerxu---lowerxu1---lowerxu2---------x-with-y2-----float-upperxu1-----highx---position-x-----highx---lowx-----bottomleftuvs-u-------float-upperxu2-----position-x---lowx-----highx---lowx-----bottomrightuvs-u-------float-upperxu---upperxu1---upperxu2---------y-with-interpolated-x-----float-yu1-----highy---position-y-----highy---lowy-----lowerxu------float-yu2-----position-y---highy-----highy---lowy-----upperxu------float-yu---yu1---yu2----------repeat-the-same-interpolation-on-the-v-values--------x-with-y1-----float-lowerxv1-----highx---position-x-----highx---lowx-----topleftuvs-v-------float-lowerxv2-----position-x---lowx-----highx---lowx-----toprightuvs-v-------float-lowerxv---lowerxv1---lowerxv2---------x-with-y2-----float-upperxv1-----highx---position-x-----highx---lowx-----bottomleftuvs-v-------float-upperxv2-----position-x---lowx-----highx---lowx-----bottomrightuvs-v-------float-upperxv---upperxv1---upperxv2---------y-with-interpolated-x-----float-yv1-----highy---position-y-----highy---lowy-----lowerxv------float-yv2-----position-y---highy-----highy---lowy-----upperxv------float-yv---yv1---yv2----------repeat-the-same-interpolation-on-the-speed--------x-with-y1-----float-lowerxs1-----highx---position-x-----highx---lowx-----topleftuvs-s-------float-lowerxs2-----position-x---lowx-----highx---lowx-----toprightuvs-s-------float-lowerxs---lowerxs1---lowerxs2---------x-with-y2-----float-upperxs1-----highx---position-x-----highx---lowx-----bottomleftuvs-s-------float-upperxs2-----position-x---lowx-----highx---lowx-----bottomrightuvs-s-------float-upperxs---upperxs1---upperxs2---------y-with-interpolated-x-----float-ys1-----highy---position-y-----highy---lowy-----lowerxs------float-ys2-----position-y---highy-----highy---lowy-----upperxs------float-ys---abs-ys1----abs-ys2--------float3-resuvs---float3-yu--yv--ys-------float-resultdirection---uvcomponentstovelocity-resuvs-------return-float2-resultdirection--resuvs-z------pre" class="not-prose"><code id="--define-pi-approx-3-1415926--float2-velocitytouvcomponents-int-degrees--float-speed-----------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------float-uvcomponentstovelocity-float3-uvs--------return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----float3-getuvsofabsoluteposition-int2-position--const-device-windgridpoint--windgrid-----------get-uv-of-a-known-point-----windgridpoint-data-point---windgrid-int-position-x-----127---int-position-y---------float2-uv---velocitytouvcomponents-data-point-angle---90--data-point-speed-------return-float3-uv-x--uv-y--data-point-speed------float4x3-getuvsofrelativeposition-float4-positions--const-device-windgridpoint--windgrid-----------get-the-values-of-the-surrounding-4-corner-coordinates--------values-are-returned-as-uv-values--described-in-uvcomponents-function-----int-lowx---positions-0-------int-lowy---positions-1-------int-highx---positions-2-------int-highy---positions-3-------float3-tl-uvs---getuvsofabsoluteposition-int2-lowx--lowy---windgrid---------top-left-coord-------relative-0-0-----float3-tr-uvs---getuvsofabsoluteposition-int2-highx--lowy---windgrid---------top-right-coord------relative-1-0-----float3-bl-uvs---getuvsofabsoluteposition-int2-lowx--highy---windgrid---------bottom-left-coord----relative-0-1-----float3-br-uvs---getuvsofabsoluteposition-int2-highx--highy---windgrid------bottom-right-coord---relative-1-1------return-float4x3-tl-uvs--tr-uvs--bl-uvs--br-uvs------float3-interpolatevelocity-float2-position--const-device-windgridpoint--windgrid-----------position-is-the-adjusted-position-to-fit-the-grid--x-is-0-127--y-is-0-68------float-lowx---floor-position-x-------float-lowy---floor-position-y-------float-highx---ceil-position-x-------float-highy---ceil-position-y--------float4x3-uvs---getuvsofrelativeposition-float4-lowx--lowy--highx--highy---windgrid--------float3-topleftuvs---uvs-0-----------0-0-----float3-toprightuvs---uvs-1----------1-0-----float3-bottomleftuvs---uvs-2--------0-1-----float3-bottomrightuvs---uvs-3-------1-1-----const-uint-u---0-----u-value-----const-uint-v---1-----v-value-----const-uint-s---2-----speed-value---------interpolate-u-values--------x-with-y1-----float-lowerxu1-----highx---position-x-----highx---lowx-----topleftuvs-u-------float-lowerxu2-----position-x---lowx-----highx---lowx-----toprightuvs-u-------float-lowerxu---lowerxu1---lowerxu2---------x-with-y2-----float-upperxu1-----highx---position-x-----highx---lowx-----bottomleftuvs-u-------float-upperxu2-----position-x---lowx-----highx---lowx-----bottomrightuvs-u-------float-upperxu---upperxu1---upperxu2---------y-with-interpolated-x-----float-yu1-----highy---position-y-----highy---lowy-----lowerxu------float-yu2-----position-y---highy-----highy---lowy-----upperxu------float-yu---yu1---yu2----------repeat-the-same-interpolation-on-the-v-values--------x-with-y1-----float-lowerxv1-----highx---position-x-----highx---lowx-----topleftuvs-v-------float-lowerxv2-----position-x---lowx-----highx---lowx-----toprightuvs-v-------float-lowerxv---lowerxv1---lowerxv2---------x-with-y2-----float-upperxv1-----highx---position-x-----highx---lowx-----bottomleftuvs-v-------float-upperxv2-----position-x---lowx-----highx---lowx-----bottomrightuvs-v-------float-upperxv---upperxv1---upperxv2---------y-with-interpolated-x-----float-yv1-----highy---position-y-----highy---lowy-----lowerxv------float-yv2-----position-y---highy-----highy---lowy-----upperxv------float-yv---yv1---yv2----------repeat-the-same-interpolation-on-the-speed--------x-with-y1-----float-lowerxs1-----highx---position-x-----highx---lowx-----topleftuvs-s-------float-lowerxs2-----position-x---lowx-----highx---lowx-----toprightuvs-s-------float-lowerxs---lowerxs1---lowerxs2---------x-with-y2-----float-upperxs1-----highx---position-x-----highx---lowx-----bottomleftuvs-s-------float-upperxs2-----position-x---lowx-----highx---lowx-----bottomrightuvs-s-------float-upperxs---upperxs1---upperxs2---------y-with-interpolated-x-----float-ys1-----highy---position-y-----highy---lowy-----lowerxs------float-ys2-----position-y---highy-----highy---lowy-----upperxs------float-ys---abs-ys1----abs-ys2--------float3-resuvs---float3-yu--yv--ys-------float-resultdirection---uvcomponentstovelocity-resuvs-------return-float2-resultdirection--resuvs-z-----"><pre id="--define-pi-approx-3-1415926--float2-velocitytouvcomponents-int-degrees--float-speed-----------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------float-uvcomponentstovelocity-float3-uvs--------return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----float3-getuvsofabsoluteposition-int2-position--const-device-windgridpoint--windgrid-----------get-uv-of-a-known-point-----windgridpoint-data-point---windgrid-int-position-x-----127---int-position-y---------float2-uv---velocitytouvcomponents-data-point-angle---90--data-point-speed-------return-float3-uv-x--uv-y--data-point-speed------float4x3-getuvsofrelativeposition-float4-positions--const-device-windgridpoint--windgrid-----------get-the-values-of-the-surrounding-4-corner-coordinates--------values-are-returned-as-uv-values--described-in-uvcomponents-function-----int-lowx---positions-0-------int-lowy---positions-1-------int-highx---positions-2-------int-highy---positions-3-------float3-tl-uvs---getuvsofabsoluteposition-int2-lowx--lowy---windgrid---------top-left-coord-------relative-0-0-----float3-tr-uvs---getuvsofabsoluteposition-int2-highx--lowy---windgrid---------top-right-coord------relative-1-0-----float3-bl-uvs---getuvsofabsoluteposition-int2-lowx--highy---windgrid---------bottom-left-coord----relative-0-1-----float3-br-uvs---getuvsofabsoluteposition-int2-highx--highy---windgrid------bottom-right-coord---relative-1-1------return-float4x3-tl-uvs--tr-uvs--bl-uvs--br-uvs------float3-interpolatevelocity-float2-position--const-device-windgridpoint--windgrid-----------position-is-the-adjusted-position-to-fit-the-grid--x-is-0-127--y-is-0-68------float-lowx---floor-position-x-------float-lowy---floor-position-y-------float-highx---ceil-position-x-------float-highy---ceil-position-y--------float4x3-uvs---getuvsofrelativeposition-float4-lowx--lowy--highx--highy---windgrid--------float3-topleftuvs---uvs-0-----------0-0-----float3-toprightuvs---uvs-1----------1-0-----float3-bottomleftuvs---uvs-2--------0-1-----float3-bottomrightuvs---uvs-3-------1-1-----const-uint-u---0-----u-value-----const-uint-v---1-----v-value-----const-uint-s---2-----speed-value---------interpolate-u-values--------x-with-y1-----float-lowerxu1-----highx---position-x-----highx---lowx-----topleftuvs-u-------float-lowerxu2-----position-x---lowx-----highx---lowx-----toprightuvs-u-------float-lowerxu---lowerxu1---lowerxu2---------x-with-y2-----float-upperxu1-----highx---position-x-----highx---lowx-----bottomleftuvs-u-------float-upperxu2-----position-x---lowx-----highx---lowx-----bottomrightuvs-u-------float-upperxu---upperxu1---upperxu2---------y-with-interpolated-x-----float-yu1-----highy---position-y-----highy---lowy-----lowerxu------float-yu2-----position-y---highy-----highy---lowy-----upperxu------float-yu---yu1---yu2----------repeat-the-same-interpolation-on-the-v-values--------x-with-y1-----float-lowerxv1-----highx---position-x-----highx---lowx-----topleftuvs-v-------float-lowerxv2-----position-x---lowx-----highx---lowx-----toprightuvs-v-------float-lowerxv---lowerxv1---lowerxv2---------x-with-y2-----float-upperxv1-----highx---position-x-----highx---lowx-----bottomleftuvs-v-------float-upperxv2-----position-x---lowx-----highx---lowx-----bottomrightuvs-v-------float-upperxv---upperxv1---upperxv2---------y-with-interpolated-x-----float-yv1-----highy---position-y-----highy---lowy-----lowerxv------float-yv2-----position-y---highy-----highy---lowy-----upperxv------float-yv---yv1---yv2----------repeat-the-same-interpolation-on-the-speed--------x-with-y1-----float-lowerxs1-----highx---position-x-----highx---lowx-----topleftuvs-s-------float-lowerxs2-----position-x---lowx-----highx---lowx-----toprightuvs-s-------float-lowerxs---lowerxs1---lowerxs2---------x-with-y2-----float-upperxs1-----highx---position-x-----highx---lowx-----bottomleftuvs-s-------float-upperxs2-----position-x---lowx-----highx---lowx-----bottomrightuvs-s-------float-upperxs---upperxs1---upperxs2---------y-with-interpolated-x-----float-ys1-----highy---position-y-----highy---lowy-----lowerxs------float-ys2-----position-y---highy-----highy---lowy-----upperxs------float-ys---abs-ys1----abs-ys2--------float3-resuvs---float3-yu--yv--ys-------float-resultdirection---uvcomponentstovelocity-resuvs-------return-float2-resultdirection--resuvs-z------pre" class="not-prose"><code id="--define-pi-approx-3-1415926--float2-velocitytouvcomponents-int-degrees--float-speed-----------to-receive-interpolatable-rotational-degrees--we-must-seperate-the--------angle-into-it-s-u-and-v-values--u-and-v-are-the-values-that-would--------be-graphed-as-x-and-y-values-respectively-----float-u----speed---sin-2---pi-approx---degrees---360-------float-v----speed---cos-2---pi-approx---degrees---360-------return-float2-u-v------float-uvcomponentstovelocity-float3-uvs--------return--atan2-uvs-y--uvs-x----360---2---pi-approx----180-----float3-getuvsofabsoluteposition-int2-position--const-device-windgridpoint--windgrid-----------get-uv-of-a-known-point-----windgridpoint-data-point---windgrid-int-position-x-----127---int-position-y---------float2-uv---velocitytouvcomponents-data-point-angle---90--data-point-speed-------return-float3-uv-x--uv-y--data-point-speed------float4x3-getuvsofrelativeposition-float4-positions--const-device-windgridpoint--windgrid-----------get-the-values-of-the-surrounding-4-corner-coordinates--------values-are-returned-as-uv-values--described-in-uvcomponents-function-----int-lowx---positions-0-------int-lowy---positions-1-------int-highx---positions-2-------int-highy---positions-3-------float3-tl-uvs---getuvsofabsoluteposition-int2-lowx--lowy---windgrid---------top-left-coord-------relative-0-0-----float3-tr-uvs---getuvsofabsoluteposition-int2-highx--lowy---windgrid---------top-right-coord------relative-1-0-----float3-bl-uvs---getuvsofabsoluteposition-int2-lowx--highy---windgrid---------bottom-left-coord----relative-0-1-----float3-br-uvs---getuvsofabsoluteposition-int2-highx--highy---windgrid------bottom-right-coord---relative-1-1------return-float4x3-tl-uvs--tr-uvs--bl-uvs--br-uvs------float3-interpolatevelocity-float2-position--const-device-windgridpoint--windgrid-----------position-is-the-adjusted-position-to-fit-the-grid--x-is-0-127--y-is-0-68------float-lowx---floor-position-x-------float-lowy---floor-position-y-------float-highx---ceil-position-x-------float-highy---ceil-position-y--------float4x3-uvs---getuvsofrelativeposition-float4-lowx--lowy--highx--highy---windgrid--------float3-topleftuvs---uvs-0-----------0-0-----float3-toprightuvs---uvs-1----------1-0-----float3-bottomleftuvs---uvs-2--------0-1-----float3-bottomrightuvs---uvs-3-------1-1-----const-uint-u---0-----u-value-----const-uint-v---1-----v-value-----const-uint-s---2-----speed-value---------interpolate-u-values--------x-with-y1-----float-lowerxu1-----highx---position-x-----highx---lowx-----topleftuvs-u-------float-lowerxu2-----position-x---lowx-----highx---lowx-----toprightuvs-u-------float-lowerxu---lowerxu1---lowerxu2---------x-with-y2-----float-upperxu1-----highx---position-x-----highx---lowx-----bottomleftuvs-u-------float-upperxu2-----position-x---lowx-----highx---lowx-----bottomrightuvs-u-------float-upperxu---upperxu1---upperxu2---------y-with-interpolated-x-----float-yu1-----highy---position-y-----highy---lowy-----lowerxu------float-yu2-----position-y---highy-----highy---lowy-----upperxu------float-yu---yu1---yu2----------repeat-the-same-interpolation-on-the-v-values--------x-with-y1-----float-lowerxv1-----highx---position-x-----highx---lowx-----topleftuvs-v-------float-lowerxv2-----position-x---lowx-----highx---lowx-----toprightuvs-v-------float-lowerxv---lowerxv1---lowerxv2---------x-with-y2-----float-upperxv1-----highx---position-x-----highx---lowx-----bottomleftuvs-v-------float-upperxv2-----position-x---lowx-----highx---lowx-----bottomrightuvs-v-------float-upperxv---upperxv1---upperxv2---------y-with-interpolated-x-----float-yv1-----highy---position-y-----highy---lowy-----lowerxv------float-yv2-----position-y---highy-----highy---lowy-----upperxv------float-yv---yv1---yv2----------repeat-the-same-interpolation-on-the-speed--------x-with-y1-----float-lowerxs1-----highx---position-x-----highx---lowx-----topleftuvs-s-------float-lowerxs2-----position-x---lowx-----highx---lowx-----toprightuvs-s-------float-lowerxs---lowerxs1---lowerxs2---------x-with-y2-----float-upperxs1-----highx---position-x-----highx---lowx-----bottomleftuvs-s-------float-upperxs2-----position-x---lowx-----highx---lowx-----bottomrightuvs-s-------float-upperxs---upperxs1---upperxs2---------y-with-interpolated-x-----float-ys1-----highy---position-y-----highy---lowy-----lowerxs------float-ys2-----position-y---highy-----highy---lowy-----upperxs------float-ys---abs-ys1----abs-ys2--------float3-resuvs---float3-yu--yv--ys-------float-resultdirection---uvcomponentstovelocity-resuvs-------return-float2-resultdirection--resuvs-z-----"># define pi_approx 3.1415926

float2 velocityToUVComponents(int degrees, float speed) {
    // To receive interpolatable rotational degrees, we must seperate the
    // angle into it&#x27;s U and V values. U and V are the values that would
    // be graphed as X and Y values respectively
    float u = -speed * sin(2 * pi_approx * degrees / 360);
    float v = -speed * cos(2 * pi_approx * degrees / 360);
    return float2(u,v);
}

float uvComponentstoVelocity(float3 uvs) {
    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;
}

float3 getUVsOfAbsolutePosition(int2 position, const device WindGridPoint *windGrid) {
    // Get UV of a known point
    WindGridPoint data_point = windGrid[int(position.x) + (127 * int(position.y))];
    float2 uv = velocityToUVComponents(data_point.angle - 90, data_point.speed);
    return float3(uv.x, uv.y, data_point.speed);
}

float4x3 getUVsOfRelativePosition(float4 positions, const device WindGridPoint *windGrid) {
    // Get the values of the surrounding 4 corner coordinates
    // Values are returned as UV values, described in uvComponents function
    int lowX = positions[0];
    int lowY = positions[1];
    int highX = positions[2];
    int highY = positions[3];
    float3 tl_uvs = getUVsOfAbsolutePosition(int2(lowX, lowY), windGrid);    // Top Left Coord;      Relative 0,0
    float3 tr_uvs = getUVsOfAbsolutePosition(int2(highX, lowY), windGrid);    // Top Right Coord;     Relative 1,0
    float3 bl_uvs = getUVsOfAbsolutePosition(int2(lowX, highY), windGrid);    // Bottom Left Coord;   Relative 0,1
    float3 br_uvs = getUVsOfAbsolutePosition(int2(highX, highY), windGrid); // Bottom Right Coord;  Relative 1,1

    return float4x3(tl_uvs, tr_uvs, bl_uvs, br_uvs);
}

float3 interpolateVelocity(float2 position, const device WindGridPoint *windGrid) {
    // position is the adjusted position to fit the grid. X is 0-127, Y is 0-68

    float lowX = floor(position.x);
    float lowY = floor(position.y);
    float highX = ceil(position.x);
    float highY = ceil(position.y);

    float4x3 uvs = getUVsOfRelativePosition(float4(lowX, lowY, highX, highY), windGrid);

    float3 topLeftUVS = uvs[0];      // 0,0
    float3 topRightUVS = uvs[1];     // 1,0
    float3 bottomLeftUVS = uvs[2];   // 0,1
    float3 bottomRightUVS = uvs[3];  // 1,1
    const uint U = 0; // U value
    const uint V = 1; // V value
    const uint S = 2; // Speed value

    // Interpolate U values
    // x with y1
    float lowerXU1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[U];
    float lowerXU2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[U];
    float lowerXU = lowerXU1 + lowerXU2;
    // x with y2
    float upperXU1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[U];
    float upperXU2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[U];
    float upperXU = upperXU1 + upperXU2;
    // y with interpolated x
    float yU1 = ((highY - position.y) / (highY - lowY)) * lowerXU;
    float yU2 = ((position.y - highY) / (highY - lowY)) * upperXU;
    float yU = yU1 + yU2;

    // Repeat the same interpolation on the V values
    // x with y1
    float lowerXV1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[V];
    float lowerXV2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[V];
    float lowerXV = lowerXV1 + lowerXV2;
    // x with y2
    float upperXV1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[V];
    float upperXV2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[V];
    float upperXV = upperXV1 + upperXV2;
    // y with interpolated x
    float yV1 = ((highY - position.y) / (highY - lowY)) * lowerXV;
    float yV2 = ((position.y - highY) / (highY - lowY)) * upperXV;
    float yV = yV1 + yV2;

    // Repeat the same interpolation on the Speed
    // x with y1
    float lowerXS1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[S];
    float lowerXS2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[S];
    float lowerXS = lowerXS1 + lowerXS2;
    // x with y2
    float upperXS1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[S];
    float upperXS2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[S];
    float upperXS = upperXS1 + upperXS2;
    // y with interpolated x
    float yS1 = ((highY - position.y) / (highY - lowY)) * lowerXS;
    float yS2 = ((position.y - highY) / (highY - lowY)) * upperXS;
    float yS = abs(yS1) + abs(yS2);

    float3 resUVS = float3(yU, yV, yS);
    float resultDirection = uvComponentstoVelocity(resUVS);
    return float2(resultDirection, resUVS.z);
}
</code></pre></code></pre>
<p>Now we can just call <span id="interpolatevelocity" class="inline-code" style="background:#333;border-radius:5px;color:orange;padding:0 6px;margin:0 3px">interpolateVelocity</span> with an arbitrary point within our grid and we have our rotation in degrees as our X and our speed as our Y.</p>
<h4 id="metal" class="heading-anchor-wrapper"><a href="#metal" class="heading-anchor" style="text-decoration:none;color:inherit;display:inline-flex;align-items:center;position:relative">Metal<span class="heading-anchor-hash" style="opacity:0;margin-left:0.5rem;transition:opacity 0.2s;color:#666;font-size:0.8em">#</span></a></h4>
<pre id="---get-these-from-the-buffer--windgridpoint--windgridpointarr---windgridpoints-windgridinfo--info---windgridinfo------separated-for-clarity-float-arbitraryx---38-382921--float-arbitraryy---71-881391--float2-arbitraryposition---float2-arbitraryx--arbitraryy---float2-directionandspeed---interpolatevelocity-arbitraryposition--windgridpointarr---float-directionindegrees---directionandspeed-x--float-speed---directionandspeed-y---pre" class="not-prose"><code id="---get-these-from-the-buffer--windgridpoint--windgridpointarr---windgridpoints-windgridinfo--info---windgridinfo------separated-for-clarity-float-arbitraryx---38-382921--float-arbitraryy---71-881391--float2-arbitraryposition---float2-arbitraryx--arbitraryy---float2-directionandspeed---interpolatevelocity-arbitraryposition--windgridpointarr---float-directionindegrees---directionandspeed-x--float-speed---directionandspeed-y--"><pre id="---get-these-from-the-buffer--windgridpoint--windgridpointarr---windgridpoints-windgridinfo--info---windgridinfo------separated-for-clarity-float-arbitraryx---38-382921--float-arbitraryy---71-881391--float2-arbitraryposition---float2-arbitraryx--arbitraryy---float2-directionandspeed---interpolatevelocity-arbitraryposition--windgridpointarr---float-directionindegrees---directionandspeed-x--float-speed---directionandspeed-y---pre" class="not-prose"><code id="---get-these-from-the-buffer--windgridpoint--windgridpointarr---windgridpoints-windgridinfo--info---windgridinfo------separated-for-clarity-float-arbitraryx---38-382921--float-arbitraryy---71-881391--float2-arbitraryposition---float2-arbitraryx--arbitraryy---float2-directionandspeed---interpolatevelocity-arbitraryposition--windgridpointarr---float-directionindegrees---directionandspeed-x--float-speed---directionandspeed-y--">// Get these from the buffer:
WindGridPoint* windGridPointArr = windGridPoints
WindGridInfo* info = windGridInfo;

// Separated for clarity
float arbitraryX = 38.382921;
float arbitraryY = 71.881391;
float2 arbitraryPosition = float2(arbitraryX, arbitraryY);
float2 directionAndSpeed = interpolateVelocity(arbitraryPosition, windGridPointArr);
float directionInDegrees = directionAndSpeed.x;
float speed = directionAndSpeed.y;
</code></pre></code></pre>
<p>That&#x27;s it! Email me at <a href="mailto://brad@bread.codes">brad@bread.codes</a> if you have any questions or want to raise concerns about the efficacy of my work.</p></div></article></main></div></div><footer class="page-width text-center py-4 space-y-4 mx-auto" style="max-width:600px"><div><img alt="IE Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ie_logo.gif"/><img alt="Netscape Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ns_logo.gif"/><img alt="Notepad" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/notepad.gif"/></div><div><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/><a href="mailto:brad@bread.codes"><img alt="Email Me" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/emailme.gif"/></a><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/></div><div style="background-color:#f0f0f0"><p><b>Copyright © <!-- -->2026<!-- --> BreadCodes</b></p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"chapterHeader":null,"superTitle":null,"title":"How to interpolate wind data","date":"2022-03-09","align":"center","wider":false,"slug":"how-to-interpolate-wind-data","excerpt":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.","content":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.\n\nThis is meant to be a reference article for non-scientific projects. This article has been heavily simplified for performance and \"close enough\" approximations.\n\n## Interpolation\n\nIf you're here reading this, you probably know that _interpolation_ is used when you have a series of data, either through time or space, and you want to estimate the data between your data points. If X₀=0, Y₀=0 and X₂=2, Y₂=4, then X₁=1 means Y₁ probably equals 2. We can guess this because we can see the 2 values make up a line similar to Y=2X, or maybe it's Y=X^2. Who's to say? What's important is using the data we have around us to best-guess this.\n\n## Problem \u0026 Requirements before Interpolation\n\nMap Distortion and Scaling were unique to our project, however they may interest you in similar projects. These are not required for interpolation at all. These are for if you were planning on putting a view with an X/Y coordinate system on a map and these problems weren't handled for you.\n\n### Map Distortion\n\nOur data was given to us in a 2D space with an XY coordinate system, however it was not processed for distortion. To do that, I found these scary looking equations:\n\nx = R (λ - λ₀)\n\ny = R ln(tan(π/4 + θ/2))\n\nKey points that hopefully help:\n\n- R is the radius of the given sphere (6378137.0 meters, according to the WGS 1984 semimajor axis. I don't know what this means, it's just important)\n\n- λ₀ is the central meridian (for the Mercator projection as we're using, this is 0.0˚ longitude)\n\n- λ is the longitude in degrees (for example: -79.876884˚)\n\n- θ is the latitude in degrees (for example: 32.808445˚)\n\nThe following example is given in Metal and Python:\n\n#### Metal\n\n```c++\n// We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n// This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\nfloat2 longLatToXY(float2 coords) {\n    float radius = 6378137.0;\n    float centralMeridian = 0.0;\n    float pi_approx = 3.1415926;\n    float x = radius * (coords.x - centralMeridian);\n    float y = radius * log(tan((pi_approx / 4) + (coords.y / 2)));\n    // return in X/Y format, even though we passed in as LongLat\n    return float2(x, y);\n}\n```\n\n#### Python 3\n\n```python\nfrom numpy import log as ln\nfrom math import pi, tan\n\n# We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n# This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\ndef longLatToXY(long: float, lat: float):\n    radius = 6378137.0\n    centralMeridian = 0.0\n    x = radius * (long - centralMeridian)\n    y = radius * ln(tan((pi / 4) + (lat / 2)))\n    # return in X/Y tuple format, even though we passed in as LongLat\n    return (x, y)\n```\n\nIf that sucks, skip it for now. I did.\n\n### Map scaling\n\nMaps are scaled on an often used zoom level of 0 to ~23. 0 means the map is zoomed all the way out and a single pixel represents several hundred/thousand miles of land, while zoom level ~23 means you could zoom into a blade of grass. This scaling is exponential, and thankfully the math is super easy. If you were to overlay a view of a known size perfectly over the map, the math would be as follows to make the view scale with the map:\n\n`scale = 2^(zoom_level)`\n\nThat's it! Now for code examples.\n\n#### Metal\n\n```c++\nfloat getMapScale(float zoomLevel) {\n    return pow(2.0, zoomLevel);\n}\n\n// Some arbitrary view size that fits perfectly over the map\nfloat2 screenWidthHeight = float2(300.0, 100.0);\n// Some arbitrary zoom level I choose. Get this from your map software/library.\nfloat zoomLevel = 4.6;\n\nfloat2 screenScaledWidthHeight = screenWidthHeight * getMapScale(zoomLevel);\n```\n\n#### Python 3\n\n```python\ndef getMapScale(zoom_level: float):\n    return pow(2, zoom_level)\n\n# Some arbitrary view size that fits perfectly over the map\nscreenWidth = 300\nscreenHeight = 100\n# Some arbitrary zoom level I choose. Get this from your map software/library.\nzoom_level = 4.6\n\nscale = getMapScale(zoom_level)\nscreenScaledWidth = scale * screenWidth\nscreenScaledHeight = scale * screenHeight\n```\n\n### Bilinear Interpolation\n\nFinally, we are handling interpolation. I don't know the exact name for this method, but I do know it is a form of bilinear interpolation (with a twist) that I accidentally made but then later found a ResearchGate post - by an actual scientist with a degree - that did the same method but significantly better. So I just copied the scientist's version and claimed it as my own, as is the engineering way.\n\nMy method of Bilinear Interpolation is regular Linear Interpolation, but its used a few times to get the values on the X axis and the Y axis separately and then together. The purpose of using Bilinear Interpolation here is because if I pick a position at random from within the view (with my 2D data overlayed) it is not going to be a clean whole number (or will be a whole number not in my evenly spaced data), so I will not have data for it. If I picked point (63.829, 12.236) but I only had data for (63, 12), (64, 12), (63, 13), (64, 13), I'd need to find what the data would be without making the visual have hard edges (aka just taking the data from the closest point [64, 12] until it gets closer to another point, creating a square around each point). That would look terrible.\n\nThe first thing you need to do is have an angle in degrees (example: 270˚). Radians work, I just don't want to explain how to do it in radians even though we're turning the angle into radians anyway. It's like 3am and I just want a drop-in method, sue me. If you want to turn your radians into degrees then do the following:\n\n`degrees = 180 / π`\n\nOnce you have your angle in degrees and a number value for your speed (miles per hour, kilometers per hour, meters per second, nautical miles per quarter-century, it doesn't matter, just get a number), we're going to break up our angle and speed into U/V values. U and V values are a way to flatten our circular angle into 2 sin/cosine lines that can be interpolated independently and rejoined. For that I have this code that might explain better:\n\n#### Metal\n\n```c++\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    float pi_approx = 3.1415926;\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n```\n\n#### Python 3\n\n```python\nfrom math import sin, cos, pi\n\ndef velocityToUVComponents(degrees: float, speed: float):\n    # To receive interpolatable rotational degrees, we must seperate the\n    # angle into it's U and V values. U and V are the values that would\n    # be graphed as X and Y values respectively\n    u = (-1 * speed) * sin(2 * pi * degrees / 360)\n    v = (-1 * speed) * cos(2 * pi * degrees / 360)\n    return (u, v)\n```\n\nand to go from UV values to degrees:\n\n#### Metal\n\n```c++\nfloat uvComponentstoVelocity(float2 uv) {\n    float pi_approx = 3.1415926;\n    // Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    // atan2(v, u) aka atan2(y, x) is the correct order\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n```\n\n#### Python 3\n\n```python\nfrom math import pi, atan2\n\ndef uvComponentsToVelocity(u: float, v: float):\n    # Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    # atan2(v, u) aka atan2(y, x) is the correct order for this use case. Don't ask why, I don't know.\n    return (atan2(v, u) * 360 / 2 / pi) + 180\n```\n\nAs I said, the purpose of this is to interpolate these U and V values independently of each other. As an added bonus, the returning angles when we're finally done with this will always be between 0-360 and wrap around appropriately. What's so special about that? Have you tried averaging 1˚ and 359˚? It comes out to 180˚ instead of 0˚ or 360˚, which is wrong. U and V values are also good if you want to find just the simple average between two angles, which is the first step of interpolation!\n\nBefore continuing, please note that in Metal I'm passing around a pointer to a 1D array (representing a flat 2D array for Swift\u003c-\u003eMetal compatibility) array of `WindGridPoint` values called `WindGridPoint *windGrid`. `WindGridPoint` is described below:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridPoint {\n    vector_float2 position;\n    float speed;\n    uint angle;\n};\n```\n\nThat is all the data I have for every point on the grid. Before I continue, I first want to mention that if you are following my example of passing around a 1D array representing a 2D array (not recommended but its easier), you need to know the size of the grid ahead of time or pass in another object like above called `WindGridInfo`:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridInfo {\n    uint width;\n    uint height;\n    uint screenWidth;\n    uint screenHeight;\n};\n```\n\nNow we can use this object to map over a 1D array as if it were a 2D array:\n\n#### Swift\n\n```swift\n// Renderer.swift\nlet info: WindGridInfo = WindGridInfo(\n    width: 300,     // number of data points on the X axis\n    height: 100,    // number of data points on the Y axis\n    screenWidth: self.view.currentDrawable.width,\n    screenHeight: self.view.currentDrawable.height\n)\n// Now pass this into your Metal pipeline\n```\n\n#### Metal\n\n```c++\n// Shaders.metal\n\nuint arr2DtoArr1D (uint x, uint y, WindGridInfo *info) {\n    return x + (y * info.width);\n}\n\n// A Vertex Pipeline that takes and executes our data from Swift. Can also be a Compute or any other pipeline type.\nvertex VertexOut vertexShader(\n  device Particle *particleArray [[buffer(0)]],\n  const device WindGridPoint *windGridPoints [[buffer(1)]],\n  const device WindGridInfo *windGridInfo [[buffer(2)]],\n  unsigned int vid [[vertex_id]]\n) {\n    // particleArray is our array of particles on the screen\n    // windGridPoints is the data for the grid\n    // * windGridInfo is what we just created that stores our grid information *\n    // vid is the index of the particleArray\n\n    WindGridInfo* info = windGridInfo;\n    uint dataPointX = 32;\n    uint dataPointY = 61;\n    uint dataPointIndex = arr2DtoArr1D(dataPointX, dataPointY, info);\n    WindGridPoint neededPoint = windGridPoints[dataPointIndex];\n}\n```\n\nThat's how I look up a data point from a properly ordered array!\n\nThe next step is described by the `getUVsOfRelativePosition` function below. What we are doing is making a square around the arbitrary point and getting the data from the 4 nearest points that create a square. For each of those points, we would use the `getUVsOfAbsolutePosition` function to get the data for that point. `getUVsOfAbsolutePosition` is using the method described above in regards to indexing a flattened 2D array.\n\nOne more note: I now use a float3 for UV values to include the speed as a z value. The \"degrees to UV code\" above has changed.\n\nThe full code for the bilinear interpolation functions for Metal, including the UV components, are below\n\n#### Metal\n\n```c++\n# define pi_approx 3.1415926\n\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n\nfloat uvComponentstoVelocity(float3 uvs) {\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n\nfloat3 getUVsOfAbsolutePosition(int2 position, const device WindGridPoint *windGrid) {\n    // Get UV of a known point\n    WindGridPoint data_point = windGrid[int(position.x) + (127 * int(position.y))];\n    float2 uv = velocityToUVComponents(data_point.angle - 90, data_point.speed);\n    return float3(uv.x, uv.y, data_point.speed);\n}\n\nfloat4x3 getUVsOfRelativePosition(float4 positions, const device WindGridPoint *windGrid) {\n    // Get the values of the surrounding 4 corner coordinates\n    // Values are returned as UV values, described in uvComponents function\n    int lowX = positions[0];\n    int lowY = positions[1];\n    int highX = positions[2];\n    int highY = positions[3];\n    float3 tl_uvs = getUVsOfAbsolutePosition(int2(lowX, lowY), windGrid);    // Top Left Coord;      Relative 0,0\n    float3 tr_uvs = getUVsOfAbsolutePosition(int2(highX, lowY), windGrid);    // Top Right Coord;     Relative 1,0\n    float3 bl_uvs = getUVsOfAbsolutePosition(int2(lowX, highY), windGrid);    // Bottom Left Coord;   Relative 0,1\n    float3 br_uvs = getUVsOfAbsolutePosition(int2(highX, highY), windGrid); // Bottom Right Coord;  Relative 1,1\n\n    return float4x3(tl_uvs, tr_uvs, bl_uvs, br_uvs);\n}\n\nfloat3 interpolateVelocity(float2 position, const device WindGridPoint *windGrid) {\n    // position is the adjusted position to fit the grid. X is 0-127, Y is 0-68\n\n    float lowX = floor(position.x);\n    float lowY = floor(position.y);\n    float highX = ceil(position.x);\n    float highY = ceil(position.y);\n\n    float4x3 uvs = getUVsOfRelativePosition(float4(lowX, lowY, highX, highY), windGrid);\n\n    float3 topLeftUVS = uvs[0];      // 0,0\n    float3 topRightUVS = uvs[1];     // 1,0\n    float3 bottomLeftUVS = uvs[2];   // 0,1\n    float3 bottomRightUVS = uvs[3];  // 1,1\n    const uint U = 0; // U value\n    const uint V = 1; // V value\n    const uint S = 2; // Speed value\n\n    // Interpolate U values\n    // x with y1\n    float lowerXU1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[U];\n    float lowerXU2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[U];\n    float lowerXU = lowerXU1 + lowerXU2;\n    // x with y2\n    float upperXU1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[U];\n    float upperXU2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[U];\n    float upperXU = upperXU1 + upperXU2;\n    // y with interpolated x\n    float yU1 = ((highY - position.y) / (highY - lowY)) * lowerXU;\n    float yU2 = ((position.y - highY) / (highY - lowY)) * upperXU;\n    float yU = yU1 + yU2;\n\n    // Repeat the same interpolation on the V values\n    // x with y1\n    float lowerXV1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[V];\n    float lowerXV2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[V];\n    float lowerXV = lowerXV1 + lowerXV2;\n    // x with y2\n    float upperXV1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[V];\n    float upperXV2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[V];\n    float upperXV = upperXV1 + upperXV2;\n    // y with interpolated x\n    float yV1 = ((highY - position.y) / (highY - lowY)) * lowerXV;\n    float yV2 = ((position.y - highY) / (highY - lowY)) * upperXV;\n    float yV = yV1 + yV2;\n\n    // Repeat the same interpolation on the Speed\n    // x with y1\n    float lowerXS1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[S];\n    float lowerXS2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[S];\n    float lowerXS = lowerXS1 + lowerXS2;\n    // x with y2\n    float upperXS1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[S];\n    float upperXS2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[S];\n    float upperXS = upperXS1 + upperXS2;\n    // y with interpolated x\n    float yS1 = ((highY - position.y) / (highY - lowY)) * lowerXS;\n    float yS2 = ((position.y - highY) / (highY - lowY)) * upperXS;\n    float yS = abs(yS1) + abs(yS2);\n\n    float3 resUVS = float3(yU, yV, yS);\n    float resultDirection = uvComponentstoVelocity(resUVS);\n    return float2(resultDirection, resUVS.z);\n}\n```\n\nNow we can just call `interpolateVelocity` with an arbitrary point within our grid and we have our rotation in degrees as our X and our speed as our Y.\n\n#### Metal\n\n```c++\n// Get these from the buffer:\nWindGridPoint* windGridPointArr = windGridPoints\nWindGridInfo* info = windGridInfo;\n\n// Separated for clarity\nfloat arbitraryX = 38.382921;\nfloat arbitraryY = 71.881391;\nfloat2 arbitraryPosition = float2(arbitraryX, arbitraryY);\nfloat2 directionAndSpeed = interpolateVelocity(arbitraryPosition, windGridPointArr);\nfloat directionInDegrees = directionAndSpeed.x;\nfloat speed = directionAndSpeed.y;\n```\n\nThat's it! Email me at [brad@bread.codes](mailto://brad@bread.codes) if you have any questions or want to raise concerns about the efficacy of my work.","categories":["data","algorithms"],"skeets":[]}},"__N_SSG":true},"page":"/archive/[slug]","query":{"slug":"how-to-interpolate-wind-data"},"buildId":"aWPEjUahS7LWqpd4h3kcq","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>