<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title></title><meta name="theme-color" content="#333333"/><meta name="title" content="bread.codes"/><meta name="author" content="BreadCodes"/><meta name="description" content="## Table of Contents"/><meta name="keywords" content="retro-computing, microcontrollers, bread.codes, breadcodes, breadbored, bread bored, bread, bored, brad, code, codes, programming, web development, software engineering, software, engineering, web, development, blog, tech, technology, computer, science, computer science, game boy, gameboy, game boy advance, GBA, gameboy advance, hacking, reverse engineering, reverse, engineering, pokemon, pokemon hacking, pokemon reverse engineering, nintendo hacking, nintendo reverse engineering, nintendo, gamefreak, game freak"/><meta name="google-adsense-account" content="ca-pub-8749505090904262"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/6e5a5c568d9bdb29.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e5a5c568d9bdb29.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-cefafc4da0529542.js" defer=""></script><script src="/_next/static/chunks/main-7aaa19766eb4191a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-1595f05012202633.js" defer=""></script><script src="/_next/static/chunks/385-85646af490fd9012.js" defer=""></script><script src="/_next/static/chunks/pages/archive/%5Bslug%5D-86c990b2ab24a3ca.js" defer=""></script><script src="/_next/static/mDJigFu9o0AXbzZMv7Rx7/_buildManifest.js" defer=""></script><script src="/_next/static/mDJigFu9o0AXbzZMv7Rx7/_ssgManifest.js" defer=""></script></head><body><div id="__next"><article class="max-w-2xl mx-auto px-4"><h1 class="text-4xl font-bold mb-4">Gameboy Printer with a RP2040 (Pi Pico) Microcontroller</h1><div class="mb-8 text-gray-600">November 30, 2022</div><div class="prose max-w-none"><h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#the-project">The Project</a></li>
<li><a href="#the-serial-protocol">The Serial Protocol</a>
<ol>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#diagrams">Diagrams</a></li>
<li><a href="#pseudocode">Pseudocode</a></li>
</ol>
</li>
<li><a href="#the-gameboy-printer">The Gameboy Printer</a></li>
<li><a href="#important-notes">Important Notes</a></li>
</ol>
<!-- -->&lt;iframe width=&quot;536&quot; height=&quot;301&quot; src=&quot;https://www.youtube.com/embed/EhVYzfLQQ70&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;<!-- -->
<p node="[object Object]">&lt;a href=&quot;https://www.patreon.com/bePatron?u=34519148&quot; data-patreon-widget-type=&quot;become-patron-button&quot;&gt;<!-- -->Become a Patron!<!-- -->&lt;/a&gt;<!-- -->&lt;script async src=&quot;https://c6.patreon.com/becomePatronButton.bundle.js&quot;&gt;<!-- -->&lt;/script&gt;</p>
<h2 id="the-project">The Project</h2>
<p node="[object Object]">The objective is to document the Gameboy Printer, it&#x27;s protocol, and the image format in a single source, and use that information to create a printer driver using a Raspberry Pi Pico.</p>
<p node="[object Object]">I originally did this project on the Arduino back in 2014 using a project that was already available, but I&#x27;m writing all of this from the ground up to better document, integrate into other Gameboy related projects, and of course bring the Gameboy Printer to the Pi family. The project I originally used was <a href="https://github.com/davedarko/GBPrinter">davedarko/GBPrinter</a> that generated PHP page to handle generating some of the code, but more recently I found that someone forked that project to bring us the improved <a href="https://github.com/octavifs/GBPrinter">octavifs/GBPrinter</a> that uses Go for generating images.</p>
<p node="[object Object]">The Raspberry Pi company have now released a $4 ARM microcontroller, and I wanted this to be as cheap as possible for other people to try.</p>
<h2 id="the-serial-protocol">The Serial Protocol</h2>
<p node="[object Object]">The Gameboy Original/Color/Advance, and by extension the Gameboy Printer, use an SPI-esque protocol to talk to each other. SPI is avery simple synchronous protocol, involving only a TX (outbound data), RX (inbound data), CLK (clock), and the CS (chip select) which the gameboy does not use. The Gameboy excludes the CS pin as it only expects to have a single master device and a single slave device.</p>
<h3 id="definitions">Definitions</h3>
<ul>
<li>Master<!-- -->
<ul>
<li>The primary device that manages the interaction</li>
</ul>
</li>
<li>Slave<!-- -->
<ul>
<li>The device being controlled by the master</li>
</ul>
</li>
<li>CLK<!-- -->
<ul>
<li>Clock</li>
<li>A signal that goes <code>HIGH</code> then <code>LOW</code> to let the slave know that the next piece of data is coming</li>
</ul>
</li>
<li>TX<!-- -->
<ul>
<li>Digital signal out from the master or slave device. Connects to the other device&#x27;s RX.</li>
</ul>
</li>
<li>RX<!-- -->
<ul>
<li>Digital signal in to the master or slave device. Connects to the other device&#x27;s TX.</li>
</ul>
</li>
<li>CS<!-- -->
<ul>
<li>Chip Select (unused)</li>
</ul>
</li>
<li>GND<!-- -->
<ul>
<li>Ground</li>
</ul>
</li>
</ul>
<h3 id="diagrams">Diagrams</h3>
<p node="[object Object]">Below is the Gameboy Color Cable pinout.</p>
<pre><code class="language-text">    _________   1 -&gt; 5v*
   / 1  2  3 \  2 -&gt; RX
  /           \ 3 -&gt; CLK
  |           | 4 -&gt; TX
  |  4  5  6  | 5 -&gt; Reserved*
  +-----------+ 6 -&gt; GND

* means we do not need that pin
</code></pre>
<p node="[object Object]">It is important to test these pins with a voltmeter because the inner cable colors are rarely correctly colored on 3rd party cables, and sources that rely on color coded wires may cause damage to your microcontroller. When you use a voltmeter to identify the TX and RX pins, remember that the TX from one end is the RX for the other and vice versa. Below will hopefully clarify what I am saying:</p>
<pre><code class="language-text">  Master        Slave
  | TX ___   ___ TX |
  |        \/       |
  |        /\       |
  | RX ---   --- RX |
</code></pre>
<p node="[object Object]">Each clock cycle (HIGH/LOW or 1/0) only one bit of data is transferred. Data is sent and read on the rising edge of the clock; rising edge meaning the short ±1 microsecond when the clock goes from LOW to HIGH. The following is an ASCII diagram from the oscilloscope where the number <code>162</code> (<code>0xA2</code> in hex or <code>10100010</code> in binary). The Gameboy has a clock speed of 8192 bits per second (8kb/s), which is 1KB/s or 1 bit every ~122μs.</p>
<p node="[object Object]">Both the master and slave can send and receive data at the same time. Once 8 bits have been sent/received they are processed as a byte.</p>
<pre><code>Clock: ^ denotes rising edge, * denotes falling edge
TX: sending `10100010` in binary (`0xA2` in hex)
RX: receiving `0b11001100` in binary (`0xCC` in hex)

                       ┏━━━━━━━━┓
    ┏━━━━━━━━━━━━━━━━━━┛ 1 byte ┗━━━━━━━━━━━━━━━━━━┓
       __    __    __    __    __    __    __    __
CLK __/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \
      ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *
       __          __                      __
TX  __/  \________/  \____________________/  \______
      1     0     1     0     0     0     1     0
       __    __                __    __
RX  __/  \__/  \______________/  \__/  \____________
      1     1     0     0     1     1     0     0
</code></pre>
<h3 id="pseudocode">Pseudocode</h3>
<p node="[object Object]">Generally, the master would look like this pseudocode where it drives the clock:</p>
<pre><code>byte data_to_send = 0xA2;
byte data_receiving = 0x00;

// Used for bit-shifting data
int data_bit_position = 0;

// 1 is HIGH, 0 is LOW
state clock_state = 1;

int clock_speed = 8192;

while (data_bit_position &lt; 8) {
  // Flip the state to what we&#x27;re about to process
  clock_state = clock_state == 1 ? 0 : 1;
  // Send the clock state to the Gameboy Printer cable
  set_clock(clock_state);

  // Send data on rising edge
  if (clock_state == 1) {
    // Send data
    state bit_to_send = (data_to_send &gt;&gt; data_bit_position) &amp; 0b00000001; // Results in  1 or 0
    set_tx(bit_to_send);

    // Receive Data
    data_receiving = (get_rx() &lt;&lt; data_bit_position) | data_receiving;

    // Set the position for the next bit
    if (++data_bit_position == 8) {
      // Reset to read and send the next byte
      data_bit_position = 0;
      data_receiving = 0x00;
    }
  }

  // 1,000,000μs in a second
  // Wait 1,000,000/clock_speed in microseconds to match the clock speed
  // Divide it by 2 so that the rising edge and falling edge take place within one cycle period
  sleep_us(1000000 / clock_speed / 2);
}
</code></pre>
<p node="[object Object]">And generally, the slave would look like this pseudocode where it waits for a state change from the clock:</p>
<pre><code>byte data_to_send = 0xA2;
byte data_receiving = 0x00;

// Used for bit-shifting data
int data_bit_position = 0;

state last_clock_state = 1;

while (data_bit_position &lt; 8) {
  state current_clock_state = get_clock();

  // Send data on rising edge
  if (current_clock_state == 1 &amp;&amp; current_clock_state !== last_clock_state) {
    last_clock_state = current_clock_state;

    // Send data
    state bit_to_send = (data_to_send &gt;&gt; data_bit_position) &amp; 0b00000001; // Results in  1 or 0
    set_tx(bit_to_send);

    // Receive Data
    data_receiving = (get_rx() &lt;&lt; data_bit_position) | data_receiving;

    // Set the position for the next bit
    if (++data_bit_position == 8) {
      // Reset to read and send the next byte
      data_bit_position = 0;
      data_receiving = 0x00;
    }
  }
}
</code></pre>
<p node="[object Object]">That pseudocode should give you an idea about what we&#x27;re working with here.</p>
<h3 id="the-gameboy-printer">The Gameboy Printer</h3>
<p node="[object Object]">Here&#x27;s the thing, this is where it gets complicated. I&#x27;ll try to break it down.</p>
<h4 id="master-to-slave">Master to Slave</h4>
<p node="[object Object]">Master TX to Slave RX is described below</p>
<h5 id="magic-bytes--2-">Magic Bytes (2)</h5>
<p node="[object Object]">This is the simplest part of the protocol. It never changes. The first byte the master sends is always <code>0x88</code> and the second byte is always <code>0x33</code>. All this does is tell the printer we are here and that we are about to send something it needs to listen to. That&#x27;s all!</p>
<h5 id="command-byte--1-">Command Byte (1)</h5>
<p node="[object Object]">This tells the printer what we want to do.</p>
<h3 id="important-notes">Important Notes</h3>
<h4 id="voltage-warnings">Voltage Warnings</h4>
<p node="[object Object]">The Pico is not 5v tolerant and can only send and receive 3.3v. <strong><em>Do not hook the Pico directly to the Gameboy Printer.</em></strong> There is a risk that a 5v signal to the Pico&#x27;s serial pins will release <a href="https://en.wikipedia.org/wiki/Magic_smoke">the magic smoke</a>. The pi doesn&#x27;t have any big capacitors so no smoke will be seen, but I think it is a lot scarier when it just silently dies and you don&#x27;t know why.</p>
<p node="[object Object]">The Gameboy Printer can only send and receive 5v, and won&#x27;t read data from the 3.3v Pico as it doesn&#x27;t seem to reach the minimum <code>HIGH</code> threshold the GBP is trying to read. This doesn&#x27;t damage anything, but it&#x27;s a major bummer.</p>
<p node="[object Object]">You will need a 3.3v to 5v logic level shifter to safely transmit and receive data, which will avoid both of these issues.</p></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Gameboy Printer with a RP2040 (Pi Pico) Microcontroller","date":"2022-12-01","slug":"gameboy-printer-with-a-rp2040-pi-pico-microcontroller","excerpt":"## Table of Contents","content":"## Table of Contents\n\n1. [The Project](#the-project)\n2. [The Serial Protocol](#the-serial-protocol)\n   1. [Definitions](#definitions)\n   2. [Diagrams](#diagrams)\n   3. [Pseudocode](#pseudocode)\n3. [The Gameboy Printer](#the-gameboy-printer)\n4. [Important Notes](#important-notes)\n\n\u003ciframe width=\"536\" height=\"301\" src=\"https://www.youtube.com/embed/EhVYzfLQQ70\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003ca href=\"https://www.patreon.com/bePatron?u=34519148\" data-patreon-widget-type=\"become-patron-button\"\u003eBecome a Patron!\u003c/a\u003e\u003cscript async src=\"https://c6.patreon.com/becomePatronButton.bundle.js\"\u003e\u003c/script\u003e\n\n## The Project\n\nThe objective is to document the Gameboy Printer, it's protocol, and the image format in a single source, and use that information to create a printer driver using a Raspberry Pi Pico.\n\nI originally did this project on the Arduino back in 2014 using a project that was already available, but I'm writing all of this from the ground up to better document, integrate into other Gameboy related projects, and of course bring the Gameboy Printer to the Pi family. The project I originally used was [davedarko/GBPrinter](https://github.com/davedarko/GBPrinter) that generated PHP page to handle generating some of the code, but more recently I found that someone forked that project to bring us the improved [octavifs/GBPrinter](https://github.com/octavifs/GBPrinter) that uses Go for generating images.\n\nThe Raspberry Pi company have now released a $4 ARM microcontroller, and I wanted this to be as cheap as possible for other people to try.\n\n## The Serial Protocol\n\nThe Gameboy Original/Color/Advance, and by extension the Gameboy Printer, use an SPI-esque protocol to talk to each other. SPI is avery simple synchronous protocol, involving only a TX (outbound data), RX (inbound data), CLK (clock), and the CS (chip select) which the gameboy does not use. The Gameboy excludes the CS pin as it only expects to have a single master device and a single slave device.\n\n### Definitions\n\n- Master\n  - The primary device that manages the interaction\n- Slave\n  - The device being controlled by the master\n- CLK\n  - Clock\n  - A signal that goes `HIGH` then `LOW` to let the slave know that the next piece of data is coming\n- TX\n  - Digital signal out from the master or slave device. Connects to the other device's RX.\n- RX\n  - Digital signal in to the master or slave device. Connects to the other device's TX.\n- CS\n  - Chip Select (unused)\n- GND\n  - Ground\n\n### Diagrams\n\nBelow is the Gameboy Color Cable pinout.\n\n```text\n    _________   1 -\u003e 5v*\n   / 1  2  3 \\  2 -\u003e RX\n  /           \\ 3 -\u003e CLK\n  |           | 4 -\u003e TX\n  |  4  5  6  | 5 -\u003e Reserved*\n  +-----------+ 6 -\u003e GND\n\n* means we do not need that pin\n```\n\nIt is important to test these pins with a voltmeter because the inner cable colors are rarely correctly colored on 3rd party cables, and sources that rely on color coded wires may cause damage to your microcontroller. When you use a voltmeter to identify the TX and RX pins, remember that the TX from one end is the RX for the other and vice versa. Below will hopefully clarify what I am saying:\n\n```text\n  Master        Slave\n  | TX ___   ___ TX |\n  |        \\/       |\n  |        /\\       |\n  | RX ---   --- RX |\n```\n\nEach clock cycle (HIGH/LOW or 1/0) only one bit of data is transferred. Data is sent and read on the rising edge of the clock; rising edge meaning the short ±1 microsecond when the clock goes from LOW to HIGH. The following is an ASCII diagram from the oscilloscope where the number `162` (`0xA2` in hex or `10100010` in binary). The Gameboy has a clock speed of 8192 bits per second (8kb/s), which is 1KB/s or 1 bit every ~122μs.\n\nBoth the master and slave can send and receive data at the same time. Once 8 bits have been sent/received they are processed as a byte.\n\n```\nClock: ^ denotes rising edge, * denotes falling edge\nTX: sending `10100010` in binary (`0xA2` in hex)\nRX: receiving `0b11001100` in binary (`0xCC` in hex)\n\n                       ┏━━━━━━━━┓\n    ┏━━━━━━━━━━━━━━━━━━┛ 1 byte ┗━━━━━━━━━━━━━━━━━━┓\n       __    __    __    __    __    __    __    __\nCLK __/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\\n      ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *\n       __          __                      __\nTX  __/  \\________/  \\____________________/  \\______\n      1     0     1     0     0     0     1     0\n       __    __                __    __\nRX  __/  \\__/  \\______________/  \\__/  \\____________\n      1     1     0     0     1     1     0     0\n```\n\n### Pseudocode\n\nGenerally, the master would look like this pseudocode where it drives the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\n// 1 is HIGH, 0 is LOW\nstate clock_state = 1;\n\nint clock_speed = 8192;\n\nwhile (data_bit_position \u003c 8) {\n  // Flip the state to what we're about to process\n  clock_state = clock_state == 1 ? 0 : 1;\n  // Send the clock state to the Gameboy Printer cable\n  set_clock(clock_state);\n\n  // Send data on rising edge\n  if (clock_state == 1) {\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n\n  // 1,000,000μs in a second\n  // Wait 1,000,000/clock_speed in microseconds to match the clock speed\n  // Divide it by 2 so that the rising edge and falling edge take place within one cycle period\n  sleep_us(1000000 / clock_speed / 2);\n}\n```\n\nAnd generally, the slave would look like this pseudocode where it waits for a state change from the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\nstate last_clock_state = 1;\n\nwhile (data_bit_position \u003c 8) {\n  state current_clock_state = get_clock();\n\n  // Send data on rising edge\n  if (current_clock_state == 1 \u0026\u0026 current_clock_state !== last_clock_state) {\n    last_clock_state = current_clock_state;\n\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n}\n```\n\nThat pseudocode should give you an idea about what we're working with here.\n\n### The Gameboy Printer\n\nHere's the thing, this is where it gets complicated. I'll try to break it down.\n\n#### Master to Slave\n\nMaster TX to Slave RX is described below\n\n##### Magic Bytes (2)\n\nThis is the simplest part of the protocol. It never changes. The first byte the master sends is always `0x88` and the second byte is always `0x33`. All this does is tell the printer we are here and that we are about to send something it needs to listen to. That's all!\n\n##### Command Byte (1)\n\nThis tells the printer what we want to do.\n\n### Important Notes\n\n#### Voltage Warnings\n\nThe Pico is not 5v tolerant and can only send and receive 3.3v. **_Do not hook the Pico directly to the Gameboy Printer._** There is a risk that a 5v signal to the Pico's serial pins will release [the magic smoke](https://en.wikipedia.org/wiki/Magic_smoke). The pi doesn't have any big capacitors so no smoke will be seen, but I think it is a lot scarier when it just silently dies and you don't know why.\n\nThe Gameboy Printer can only send and receive 5v, and won't read data from the 3.3v Pico as it doesn't seem to reach the minimum `HIGH` threshold the GBP is trying to read. This doesn't damage anything, but it's a major bummer.\n\nYou will need a 3.3v to 5v logic level shifter to safely transmit and receive data, which will avoid both of these issues.","categories":["retro-computing","microcontrollers"],"skeets":[]}},"__N_SSG":true},"page":"/archive/[slug]","query":{"slug":"gameboy-printer-with-a-rp2040-pi-pico-microcontroller"},"buildId":"mDJigFu9o0AXbzZMv7Rx7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>