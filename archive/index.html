<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/ef45fced96a47df5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef45fced96a47df5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-cefafc4da0529542.js" defer=""></script><script src="/_next/static/chunks/main-7aaa19766eb4191a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-737afb569de7792d.js" defer=""></script><script src="/_next/static/chunks/pages/archive-a151114ec6b6bf67.js" defer=""></script><script src="/_next/static/Ya4gzTM6YUh04oFuJ6rbS/_buildManifest.js" defer=""></script><script src="/_next/static/Ya4gzTM6YUh04oFuJ6rbS/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="page-width mx-auto mt-12" style="max-width:600px"><div class="pb-12 pt-6 text-center bg-white"><a href="https://sendfox.com/bread" tabindex="0"><marquee class="my-4" behavior="alternate" tabindex="0">subscribe</marquee></a><h1 class="text-4xl font-bold mb-2">bread.codes</h1><h3 class="text-xl mb-4">code stuff</h3><nav class="space-x-4 mb-8"><a class="hover:text-blue-600" href="/">Home</a><a class="hover:text-blue-600" href="/search/">Search</a><a class="hover:text-blue-600" href="/about/">About</a><a class="hover:text-blue-600" href="/archive/">Archive</a></nav><div role="group" tabindex="0" aria-label="Audio player" class="rhap_container rhap_loop--on rhap_play-status--paused mb-4"><audio src="/assets/Linkin-Park-Numb.mp3" loop="" preload="auto"></audio><div class="rhap_header">Linkin-Park-Numb.mp3</div><div class="rhap_main rhap_stacked"><div class="rhap_progress-section"><div id="rhap_current-time" class="rhap_time rhap_current-time">--:--</div><div class="rhap_progress-container" aria-label="Audio progress control" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0"><div class="rhap_progress-bar rhap_progress-bar-show-download"><div class="rhap_progress-indicator" style="left:0%"></div><div class="rhap_progress-filled" style="width:0%"></div></div></div><div class="rhap_time rhap_total-time">--:--</div></div><div class="rhap_controls-section"><div class="rhap_additional-controls"><button aria-label="Disable loop" class="rhap_button-clear rhap_repeat-button" type="button"><span></span></button></div><div class="rhap_main-controls"><button aria-label="Play" class="rhap_button-clear rhap_main-controls-button rhap_play-pause-button" type="button"><span></span></button></div><div class="rhap_volume-controls"><div class="rhap_volume-container"><button aria-label="Mute" type="button" class="rhap_button-clear rhap_volume-button"><span></span></button><div role="progressbar" aria-label="Volume control" aria-valuemin="0" aria-valuemax="100" aria-valuenow="NaN" tabindex="0" class="rhap_volume-bar-area"><div class="rhap_volume-bar"><div class="rhap_volume-indicator" style="left:40.00%;transition-duration:0s"></div></div></div></div></div></div></div></div><main class="px-4"><div class="posts"><article class="border border-black m-2.5 p-4"><a class="block" href="/archive/gameboy-printer-with-a-rp2040-pi-pico-microcontroller/"><h1 class="text-2xl font-bold mb-2">Gameboy Printer with a RP2040 (Pi Pico) Microcontroller</h1><div class="mb-4"><p class="text-gray-600">November 30, 2022</p></div></a><div class="prose max-w-none mb-4">## Table of Contents</div><a class="block" href="/archive/gameboy-printer-with-a-rp2040-pi-pico-microcontroller/"><img alt="Read more" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline" style="color:transparent" src="/assets/more.gif"/></a></article><article class="border border-black m-2.5 p-4"><a class="block" href="/archive/proprietary-wireless-l3-protocol-from-packet-traces/"><h1 class="text-2xl font-bold mb-2">Proprietary Wireless L3 Protocol From Packet Traces</h1><div class="mb-4"><p class="text-gray-600">March 8, 2022</p></div></a><div class="prose max-w-none mb-4">## Please Note</div><a class="block" href="/archive/proprietary-wireless-l3-protocol-from-packet-traces/"><img alt="Read more" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline" style="color:transparent" src="/assets/more.gif"/></a></article><article class="border border-black m-2.5 p-4"><a class="block" href="/archive/how-to-interpolate-wind-data/"><h1 class="text-2xl font-bold mb-2">How to interpolate wind data</h1><div class="mb-4"><p class="text-gray-600">March 8, 2022</p></div></a><div class="prose max-w-none mb-4">This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` &amp; `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it&#x27;s own stripped down `metal_stdlib` with apple branded alternatives such as `vec&lt;T, n&gt;` instead of `std::vector&lt;T&gt;`), etc.</div><a class="block" href="/archive/how-to-interpolate-wind-data/"><img alt="Read more" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline" style="color:transparent" src="/assets/more.gif"/></a></article></div></main></div></div><footer class="page-width text-center py-4 space-y-4 mx-auto" style="max-width:600px"><div><img alt="IE Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ie_logo.gif"/><img alt="Netscape Logo" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/ns_logo.gif"/><img alt="Notepad" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/notepad.gif"/></div><div><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/><a href="mailto:brad@bread.codes"><img alt="Email Me" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/emailme.gif"/></a><img alt="Pokemon" loading="lazy" width="88" height="31" decoding="async" data-nimg="1" class="inline mx-1" style="color:transparent" src="/assets/pokemon3.gif"/></div><div style="background-color:#f0f0f0"><p><b>Copyright © <!-- -->2025<!-- --> BreadCodes</b></p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Gameboy Printer with a RP2040 (Pi Pico) Microcontroller","date":"2022-12-01","slug":"gameboy-printer-with-a-rp2040-pi-pico-microcontroller","excerpt":"## Table of Contents","content":"## Table of Contents\n\n1. [The Project](#the-project)\n2. [The Serial Protocol](#the-serial-protocol)\n   1. [Definitions](#definitions)\n   2. [Diagrams](#diagrams)\n   3. [Pseudocode](#pseudocode)\n3. [The Gameboy Printer](#the-gameboy-printer)\n4. [Important Notes](#important-notes)\n\n\u003ciframe width=\"536\" height=\"301\" src=\"https://www.youtube.com/embed/EhVYzfLQQ70\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003ca href=\"https://www.patreon.com/bePatron?u=34519148\" data-patreon-widget-type=\"become-patron-button\"\u003eBecome a Patron!\u003c/a\u003e\u003cscript async src=\"https://c6.patreon.com/becomePatronButton.bundle.js\"\u003e\u003c/script\u003e\n\n## The Project\n\nThe objective is to document the Gameboy Printer, it's protocol, and the image format in a single source, and use that information to create a printer driver using a Raspberry Pi Pico.\n\nI originally did this project on the Arduino back in 2014 using a project that was already available, but I'm writing all of this from the ground up to better document, integrate into other Gameboy related projects, and of course bring the Gameboy Printer to the Pi family. The project I originally used was [davedarko/GBPrinter](https://github.com/davedarko/GBPrinter) that generated PHP page to handle generating some of the code, but more recently I found that someone forked that project to bring us the improved [octavifs/GBPrinter](https://github.com/octavifs/GBPrinter) that uses Go for generating images.\n\nThe Raspberry Pi company have now released a $4 ARM microcontroller, and I wanted this to be as cheap as possible for other people to try.\n\n## The Serial Protocol\n\nThe Gameboy Original/Color/Advance, and by extension the Gameboy Printer, use an SPI-esque protocol to talk to each other. SPI is avery simple synchronous protocol, involving only a TX (outbound data), RX (inbound data), CLK (clock), and the CS (chip select) which the gameboy does not use. The Gameboy excludes the CS pin as it only expects to have a single master device and a single slave device.\n\n### Definitions\n\n- Master\n  - The primary device that manages the interaction\n- Slave\n  - The device being controlled by the master\n- CLK\n  - Clock\n  - A signal that goes `HIGH` then `LOW` to let the slave know that the next piece of data is coming\n- TX\n  - Digital signal out from the master or slave device. Connects to the other device's RX.\n- RX\n  - Digital signal in to the master or slave device. Connects to the other device's TX.\n- CS\n  - Chip Select (unused)\n- GND\n  - Ground\n\n### Diagrams\n\nBelow is the Gameboy Color Cable pinout.\n\n```text\n    _________   1 -\u003e 5v*\n   / 1  2  3 \\  2 -\u003e RX\n  /           \\ 3 -\u003e CLK\n  |           | 4 -\u003e TX\n  |  4  5  6  | 5 -\u003e Reserved*\n  +-----------+ 6 -\u003e GND\n\n* means we do not need that pin\n```\n\nIt is important to test these pins with a voltmeter because the inner cable colors are rarely correctly colored on 3rd party cables, and sources that rely on color coded wires may cause damage to your microcontroller. When you use a voltmeter to identify the TX and RX pins, remember that the TX from one end is the RX for the other and vice versa. Below will hopefully clarify what I am saying:\n\n```text\n  Master        Slave\n  | TX ___   ___ TX |\n  |        \\/       |\n  |        /\\       |\n  | RX ---   --- RX |\n```\n\nEach clock cycle (HIGH/LOW or 1/0) only one bit of data is transferred. Data is sent and read on the rising edge of the clock; rising edge meaning the short ±1 microsecond when the clock goes from LOW to HIGH. The following is an ASCII diagram from the oscilloscope where the number `162` (`0xA2` in hex or `10100010` in binary). The Gameboy has a clock speed of 8192 bits per second (8kb/s), which is 1KB/s or 1 bit every ~122μs.\n\nBoth the master and slave can send and receive data at the same time. Once 8 bits have been sent/received they are processed as a byte.\n\n```\nClock: ^ denotes rising edge, * denotes falling edge\nTX: sending `10100010` in binary (`0xA2` in hex)\nRX: receiving `0b11001100` in binary (`0xCC` in hex)\n\n                       ┏━━━━━━━━┓\n    ┏━━━━━━━━━━━━━━━━━━┛ 1 byte ┗━━━━━━━━━━━━━━━━━━┓\n       __    __    __    __    __    __    __    __\nCLK __/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\\n      ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *\n       __          __                      __\nTX  __/  \\________/  \\____________________/  \\______\n      1     0     1     0     0     0     1     0\n       __    __                __    __\nRX  __/  \\__/  \\______________/  \\__/  \\____________\n      1     1     0     0     1     1     0     0\n```\n\n### Pseudocode\n\nGenerally, the master would look like this pseudocode where it drives the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\n// 1 is HIGH, 0 is LOW\nstate clock_state = 1;\n\nint clock_speed = 8192;\n\nwhile (data_bit_position \u003c 8) {\n  // Flip the state to what we're about to process\n  clock_state = clock_state == 1 ? 0 : 1;\n  // Send the clock state to the Gameboy Printer cable\n  set_clock(clock_state);\n\n  // Send data on rising edge\n  if (clock_state == 1) {\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n\n  // 1,000,000μs in a second\n  // Wait 1,000,000/clock_speed in microseconds to match the clock speed\n  // Divide it by 2 so that the rising edge and falling edge take place within one cycle period\n  sleep_us(1000000 / clock_speed / 2);\n}\n```\n\nAnd generally, the slave would look like this pseudocode where it waits for a state change from the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\nstate last_clock_state = 1;\n\nwhile (data_bit_position \u003c 8) {\n  state current_clock_state = get_clock();\n\n  // Send data on rising edge\n  if (current_clock_state == 1 \u0026\u0026 current_clock_state !== last_clock_state) {\n    last_clock_state = current_clock_state;\n\n    // Send data\n    state bit_to_send = (data_to_send \u003e\u003e data_bit_position) \u0026 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() \u003c\u003c data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n}\n```\n\nThat pseudocode should give you an idea about what we're working with here.\n\n### The Gameboy Printer\n\nHere's the thing, this is where it gets complicated. I'll try to break it down.\n\n#### Master to Slave\n\nMaster TX to Slave RX is described below\n\n##### Magic Bytes (2)\n\nThis is the simplest part of the protocol. It never changes. The first byte the master sends is always `0x88` and the second byte is always `0x33`. All this does is tell the printer we are here and that we are about to send something it needs to listen to. That's all!\n\n##### Command Byte (1)\n\nThis tells the printer what we want to do.\n\n### Important Notes\n\n#### Voltage Warnings\n\nThe Pico is not 5v tolerant and can only send and receive 3.3v. **_Do not hook the Pico directly to the Gameboy Printer._** There is a risk that a 5v signal to the Pico's serial pins will release [the magic smoke](https://en.wikipedia.org/wiki/Magic_smoke). The pi doesn't have any big capacitors so no smoke will be seen, but I think it is a lot scarier when it just silently dies and you don't know why.\n\nThe Gameboy Printer can only send and receive 5v, and won't read data from the 3.3v Pico as it doesn't seem to reach the minimum `HIGH` threshold the GBP is trying to read. This doesn't damage anything, but it's a major bummer.\n\nYou will need a 3.3v to 5v logic level shifter to safely transmit and receive data, which will avoid both of these issues.","categories":["retro-computing","microcontrollers"],"skeets":[]},{"title":"Proprietary Wireless L3 Protocol From Packet Traces","date":"2022-03-09","slug":"proprietary-wireless-l3-protocol-from-packet-traces","excerpt":"## Please Note","content":"## Please Note\n\nThis is not my work, but I am hosting it here for archival purposes. The source I am rehosting is [here](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WMBProtocol), which is a archival rehost of a a website no longer hosting the content, a website which is rehosting parts of a paper from 2005 by the same author entitled _Inferring a Proprietary Wireless L3 Protocol From Packet Traces_.\n\nThis came up in my research for the NDS Download Play protocol and it appears that the only place hosting this content is the WaybackMachine. I am hosting it here for archival purposes. If you are the original author and wish for me to take it down, please contact me at [brad@bread.codes](mailto:brad@bread.codes).\n\n## Archived Content:\n\nOriginal Note from `bottledlight.com`: This is a reformatted version of the technical content from _Inferring a Proprietary Wireless L3 Protocol From Packet Traces_ paper, and should probably be split up / otherwise wikified at some point. The ... represents a bit of the original paper that was cut.\n\nThere was also an associated [presentation](https://web.archive.org/web/20110723013725/http://www.cs.unc.edu/~jasleen/Courses/Fall05/projects/wmb_presentation.pdf) to go with the paper.\n\n....\n\nSee [Wireless Basics](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WirelessBasics) for more 802.11 frame information.\n\n# Available Game Advertisement\n\nWMB uses beacon frames to advertise available games for download. The beacon frames are normally used to advertise available access points in most 802.11 systems, but there is nothing preventing their use in this capacity. The advertisement data is fragmented and stored partially in each [beacon frame](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WirelessBasics) as the payload of a custom information element (tag: 0xDD).\n\nThe DS Download Play menu only lists games when the beacons are broadcasted on one of the following channels: 1, 3, 4, 5, 7, 9, 10, 11, 13, and 14. However, the DS hosting mechanism only seems to transmit on channels 1, 7, and 13 (apparently selected at random).\n\nAll beacon frames transmitted by a DS host have the following format:\n\n|     |\n| --- |\n| 802.11 management frame |\n| 802.11 beacon header |\n| Supported rates (tagged IE, advertises 1 Mbit and 2 Mbit) |\n| DS parameter set (tagged IE, note: Distribution System, not Nintendo DS) |\n| TIM vector (tagged IE, transmitted as empty) |\n| Custom extension (tagged IE, tag `0xDD`) |\n\nNintendo specific beacon fragment format (information element code 0xDD):\n\n| Offset | Description |\n| --- | --- |\n| `0x00` | Manufacturer (`00 09 BF`) |\n| `0x03` | `00` |\n| `0x04` | `0A 00 00 00` |\n| `0x08` | `01 00 40 00` |\n| `0x0C` | `24 00 40 00` |\n| `0x10` | Randomly generated stream code |\n| `0x12` | `70 0B` |\n| `0x14` | `00 01 08 00` |\n| `0x18` | `24 00 40 00` (varies from game to game) |\n| `0x1C` | End of advertisement flag (`00` for non-end, `02` for end packets) |\n| `0x1D` | Always `00`, `01`, `02`, or `04` |\n| `0x1E` | Number of players already connected |\n| `0x1F` | Sequence number (0 .. total\\_advertisement\\_length) |\n| `0x20` | Checksum (2 byte little-endian) |\n| `0x22` | Sequence number in non-final packet, # of players in final packet |\n| `0x23` | Total advertisement length – 1 (in beacons) |\n| `0x24` | Payload size in bytes (2 byte little-endian) |\n| `0x26` | Payload begins |\n\nThe checksum is a custom algorithm, I have included example source in the appendix.\n\nThe advertisement fragments are reordered and assembled according to their internal sequence number, to form the overall advertisement payload, as defined below:\n\n| Offset | Size | Description |\n| --- | --- | --- |\n| `0x000` | 32  | Icon palette (16 RGB555 entries) |\n| `0x020` | 512 | Icon tiles (4x4 8x8 4 bit palletized tiles) |\n| `0x220` | 1   | Unknown (0x0B) |\n| `0x221` | 1   | Length of hosting name |\n| `0x222` | 20  | Name of hosting DS (10 UCS-2) |\n| `0x236` | 1   | Max number of players |\n| `0x237` | 1   | Unknown (0x00) |\n| `0x238` | 96  | Game name (48 UCS-2) |\n| `0x298` | 192 | Game description (96 UCS-2) |\n| `0x358` | 64  | 00’s if no users are connected |\n| `0x398` | 0   | End of data if no users are connected |\n\nThe game name and game description are parsed out of the 128 characters stored in the .NDS file banner area. The game name comes from the first line of the banner, and the remaining lines go into the description. No WMB downloads have been observed that had more than 128 characters for these two fields combined, but it should be possible.\n\nThe icon format is a standard DS graphics format, constructing the 32x32 icon out of 8x8 pixel tiles, where each pixel is a 4-bit index into a 16-color palette. The 0th palette index is designated as transparent, allowing the background to show through. This also comes from the banner area of the original NDS file.\n\n# Authentication process\n\nOnce a user B chooses a download offered by a host A, the following standard 802.11 authentication process observed.\n\n1.  Host A advertises a game in beacon frames as described above\n2.  Client B sends an authentication request (sequence 1) to A\n3.  Host A replies with an ACK\n4.  Host A sends an authentication reply (sequence 2) to B\n5.  Client B replies with an association request\n6.  Host A replies with an ACK\n7.  Host A sends an association response\n8.  Client B responds with an ACK\n\nAfter this, the two are associated, and will remain so until the transfer is complete or one is idle for several seconds, at which point they will de-associate. For more information on the association process, see the 802.11 standard.\n\n# Download process\n\nAfter authentication:\n\n1.  Host sends Pings (type 0x01, replies are 0x00, 0x07)\n2.  Host sends RSA frame (type 0x03, replies 0x08)\n3.  Host sends NDS header (type 0x04, replies 0x09)\n4.  Host sends ARM9 binary (type 0x04, replies 0x09)\n5.  Host sends ARM7 binary (type 0x04, replies 0x09)\n6.  Host terminates transfer (type 0x05, no replies)\n\nThe WMB protocol ostensibly implements layers 3 to 7 of the OSI network model, but does not define a new type of network addresses. However, it does define a couple of special broadcast-like MAC addresses within the assigned Nintendo namespace (`00:09:BF`).\n\nThe three channels or flows used for all communications after the MAC broadcast beacons take the form `03:09:BF:00:00:xx`, where xx is:\n\n*   00 for the main data flow, from host to client\n*   10 for the client to host replies\n*   03 for the feedback flow, host to client (acknowledges the replies)\n\nObserved commands:\n\n| Command | Description |\n| --- | --- |\n| 0x01 | Ping / Name request |\n| 0x03 | RSA signature frame |\n| 0x04 | Data packet |\n| 0x05 | Post-idle / unknown |\n\nObserved replies\n\n| Reply ID | Description |\n| --- | --- |\n| 0x00 | Pong (ping reply) |\n| 0x07 | Name reply |\n| 0x08 | RSA frame reply |\n| 0x09 | Data packet reply |\n\nThe host does something unusual with the 802.11 sequence control field, each packet sent out on the 00 flow has a sequence control number 2 greater than the previous one, even if they are sent sequentially. When the host acknowledges a reply (on flow 03) from the client about a particular packet, it uses the sequence number one after the original packet number it sent out on 00. This is the root of one of the major problems in finding a PC card that can transmit WMB packets, as very few cards provide user control over it. Even when a card is capable of ‘raw’ 802.11 transmission, it typically takes care of the sequence control field in hardware or firmware, filling it with a constantly incrementing number.\n\n# Host-to-client packets (on the 0x00 flow)\n\n| 0   | 1   | 2   | 3   | 4   | 5   | 6..e-3 | e-2 | e-1 | e-0 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 06  | 01  | 02  | 00  | Size | Flags | Payload | 00  | 02  | 00  |\n\nNotes:\n\n*   The size field is in terms of half-words (16 bits), and includes the flags byte along with the payload (so a size of 0x03 represents a flag byte, a command byte, and 4 bytes of payload).\n*   When flags is 0x11, the first byte of the payload is a command. There seems to be no important data when flags is not 0x11 (seen occasionally as 0x01), and ignoring them still results in a complete dump.\n\nThe Ping messages (type 0x00) have a payload size of 0x03, but always contain zeroes in the payload. They seem to be used only to keep the connection alive while waiting for the host DS to start the transfer, to prevent a time-out de-association.\n\nThe RSA frame format (type 0x03) sends a table of information about the game being downloaded (most of it redundant with the NDS header, see Appendix), as well as the RSA signature for the DS. I have not looked into computing the signature, as homebrew developers are not privy to Nintendo’s private key, making signing a fruitless activity, but it is my understanding that the signature is a 128 byte public key and an 8 byte SHA-1 message digest over the NDS header, ARM9 binary, and ARM7 binary. Notably: the RSA frame itself is not included as part of the data being signed, bringing up various security issues and making Nintendo’s firmware engineers look amateurish at best.\n\nThere are several abortive sendings of empty RSA frames with a size field of 0x03, before the real frame is sent (always with a size field of 0x75).\n\n|     |     |     |\n| --- | --- | --- |RSA signature frame payload (type 0x03)\n| Offset | Size | Description |\n| `0x00` | `4` | ARM9 execute address |\n| `0x04` | `4` | ARM7 execute address |\n| `0x08` | `4` | `0x00` |\n| `0x0C` | `4` | Header destination |\n| `0x10` | `4` | Header destination |\n| `0x14` | `4` | Header size (0x160) |\n| `0x18` | `4` | `0x00` |\n| `0x1C` | `4` | ARM9 destination address |\n| `0x20` | `4` | ARM9 destination address |\n| `0x24` | `4` | ARM9 binary size |\n| `0x28` | `4` | `0x00` |\n| `0x2C` | `4` | `0x022C0000` |\n| `0x30` | `4` | ARM7 destination address |\n| `0x34` | `4` | ARM7 binary size |\n| `0x38` | `4` | `0x01` |\n| `0x3C` | `136` | Signature block |\n| `0xC4` | `36` | `0x00`’s |\n| `0xE8` | `0` | End of frame payload |\n\nNotes:\n\n*   The offsets in the table are from after the command byte, i.e. two bytes into the 234 bytes of payload including the flags.\n*   The unknown address 0x022C0000 is probably ARM7 related, by comparison with the duplicated header and ARM9 destination addresses 32 and 16 bytes before it, although it has no known significance according to the NDS header.\n\nThe data packets (type 0x04) include a transport-layer sequence number inside of the data packet itself, but no destination offset or other mechanism to allow the packets to be processed out-of-order. The only way to place the data at the correct location in memory is to re-order the packets according to the sequence number and process them sequentially.\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |Data packet (type 0x04)\n| 0   | 1   | 2   | 3   | ..  | End |\n| 00  | \\[Sequence #\\] |     | xx  | ..  | yy  |\n\nThe sequence number is a zero based little-endian number. Each packet only contains data for one of the three destination blocks (header, ARM9, ARM7), so the change-of-destination check only needs to be made on packet boundaries.\n\n# Client to Host Replies (on the 0x10 flow)\n\nThe replies from client to host are sent on the 0x10 flow. The client uses an incrementing sequence control number for all of its packets, with no unusual trickery. Each reply is sent as a standard 802.11 data frame (typically as a Data + CF-Acknowledgement), consisting of 10 data bytes for the WMB payload. The first two are always 0x04 0x81, with the third byte indicating the type of reply, and the remaining 7 bytes being reply-specific.\n\nOne type of packet frequently sent before a download gets underway is what I have termed the Idle or Pong packet (in response to 0x00 ‘Pings’). It has a reply type field of 0x00, and does not contribute any additional information.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Idle / Pong reply (type 0x00)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `00` | `00` | `00` | `00` | `00` | `00` | `00` | `00` |\n\nThe name reply (type 0x07) is sent shortly after association is completed, although I am not certain what triggers it. There are a variable number of pings preceding this reply, but most are replied via Pongs. The name reply sends the user-configured DS name (set in the firmware menu) split over four messages (with the 4th byte of the packet specifying which message fragment this is, 1 based). This can be a total length of 10 UCS-2 characters, although all four messages are still sent if it is shorter (padded with nulls to 10 characters, and then 01 and then nulls until the end of the frame).\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Name reply (type 0x07)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `07` | `01` | \\[Character0\\] |     | \\[Character1\\] |     | \\[Character2\\] |     |\n| `04` | `81` | `07` | `02` | \\[Character3\\] |     | \\[Character4\\] |     | \\[Character5\\] |     |\n| `04` | `81` | `07` | `03` | \\[Character6\\] |     | \\[Character7\\] |     | \\[Character8\\] |     |\n| `04` | `81` | `07` | `04` | \\[Character9\\] |     | `01` | `00` | `00` | `00` |\n\nThe RSA frame receipt reply contains no extra information; it only acknowledges receipt of a type 0x03 host packet on the main flow (0x00). Bizarrely, the xx bytes in the table below are not driven to a particular value when replying to an RSA frame, and usually contain the same data as the second (of four) name response frames.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |RSA frame receipt reply (type 0x08)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `08` | `xx` | `xx` | `xx` | `xx` | `xx` | `xx` | `xx` |\n\nThe data packet receipt reply implements is interesting in that it includes both an immediate acknowledgement and something akin to a cumulative acknowledgement. It specifies the transport layer sequence number for both the packet just received, and the highest continuously addressed packet received.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Data packet receipt reply (type 0x09)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `09` | \\[Last packet\\] |     | \\[Best packet\\] |     | `00` | `00` | `00` |\n\nNotes:\n\n*   \\[last packet\\] is the packet number being acknowledged\n*   \\[best packet\\] is the highest continuous packet number seen so far\n*   Packet IDs are little-endian numbers, like other Nintendo provided data.\n\n# Host to client acknowledgements (on the 0x03 flow)\n\nThese packets contain four data bytes, but three are always zero. The first seems to be random, with no connection to the acknowledged data. The actual indication of acknowledgement is the sequence control number of the packet. It is set to be one greater than the sequence control number of the initial host packet (sent on flow 0x00) that the client has just responded to, to indicate that the reply was received.\n\n|     |     |     |     |\n| --- | --- | --- | --- |Host-to-client acknowledgement\n| 0   | 1   | 2   | 3   |\n| `??` | `00` | `00` | `00` |\n\n# Experimental Verification of Protocol\n\nAn experiment was setup to test some assumptions about the protocol and verify that clean working dumps of WMB transfers could be made.\n\n1.  The Peanuts program was run on a laptop placed near to a DS running the game Polarium.\n2.  The Send a Demo option in the Polarium menu was invoked, and Peanuts was checked to make sure both were operating on the same channel.\n3.  Another DS was turned on in a different room, and the hosted Polarium demo was selected in the DS Download Play menu, and the transfer was allowed to complete.\n4.  Peanut wrote out a reassembled .NDS file as well as an annotated trace log.\n5.  The trace log was checked to make sure the reassembly completed.\n6.  The reassembled file was also checked for file integrity with DSgrok.\n7.  The WMB program was invoked with the captured demo, and a DS with unmodified firmware (i.e. will reject a game with even a single modified byte due to the RSA signature) was used to download the demo.\n8.  The demo ran successfully without the characteristic faded logo lockup indicating a failed signature check, indicating that the capture and reassembly process works, at least for this demo.\n\n# Conclusions and Future Work\n\nThe NiFi protocol, simply put, isn’t. Although both PictoChat and the DS Download Play have some similarities indicating that the same people wrote both programs (which seems likely considering they are both part of the same firmware), there is not a common layer 3 / 4 protocol shared between them.\n\nThe Nintendo DS does not appear to violate the letter of the 802.11 standard. However, most cards are not capable of providing application level control of the sequence number, and many card drivers do not even allow non-IP transmission over 802.11, filtering out incoming packets and providing no interface to send outbound ones.\n\nThe RSA signature frame is a curious design decision. They had to send a signature of the binaries across, but the RSA frame also contains duplicated header fields, including execute addresses. Under other circumstances, this would be a trivial waste of space; except that the signature does not cover the RSA frame itself, and it’s fields are preferentially used over the original header! This means that a DS download server can also operate as a software-based passthrough. Arbitrary code cannot be sent, as the binaries are still signed, but execution can be redirected to a flash cartridge in the GBA slot.\n\n... The additional information in the RSA firmware is ignored by newer versions of the [firmware](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Main/Firmware), completely preventing the WifiMe soft-passthrough. ...\n\nThe passive method of capture currently implemented in Peanut is sufficient when the client DS is sufficiently far away from the host DS to commonly request the same packet several times. By the very nature of wireless systems, packets have a high loss rate, even when the sender (host) and receiver (laptop) are quite close. If even a single packet is completely lost (i.e. the laptop missed it each time it was (re)transmitted to the client), then reassembly is impossible. The client DS gets around this by not acknowledging packets that were dropped, allowing the host to timeout and retransmit. As a passive snooper, we can’t work around this if the client receives the packet and we do not.\n\nMoving to an active capture system, where Peanut pretends to be a client DS will provide flawless captures every time, and could also lead to a program running on the DS, providing WMB style downloads on DS units that do not have FlashMe installed. As most of the machinery associated with being an active client is common to being an active server, hopefully this would also lead to the first homebrew WMB broadcasts from a DS.\n\n...\n\n# Appendix\n\nThe beacon checksum is a custom algorithm, operating over the payload as half-words. Here is an example of how to compute it.\n\n \n// The checksum is computed over halfwords for the last 4 bytes\n// of the ninty beacon header, plus the payload\n// This func takes length in halfwords\nuint16 computeBeaconChecksum(uint16 \\* data, int length) {\n  uint32 sum = 0;\n  for (int j = 0; j \u003c length; j++) sum += \\*data++;\n  sum = (-((sum \u003e\u003e 16) + (sum \u0026 0xFFFF) + 1)) \u0026 0xFFFF;\n  return sum;\n}\n\nThe .NDS format is the standard format for Nintendo DS programs; it originated on original game cards and also appears to a limited extent in WMB binaries. The WMB process only transfers the first 0x160 bytes of the header, the ARM9 binary, and the ARM7 binary (in that order), ignoring the file name and file allocation tables, the overlay data, and some information stored in the banner (the rest is transmitted partially via the beacon advertisement process).\n\n(No point in duplicating NDS header info here, see the [NDS Format](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/FileFormats/NDSFormat) page instead.)","categories":["nintendo","ds","nds","download play","wireless","protocol","reverse engineering","wmb","nifi","rsa"],"skeets":[]},{"title":"How to interpolate wind data","date":"2022-03-09","slug":"how-to-interpolate-wind-data","excerpt":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.","content":"This article is a work in progress and will be revised several times. This is a loose series of words and code blocks to put my thoughts into words to help myself better understand the work I am doing. Please note that Metal is a c++-**_like_** language and is missing many core features of C++11 such as `new` \u0026 `delete` operators, `memalloc`, `memset`, `free`, inheritance/derived classes, the foundational `stdlib` (though it comes with it's own stripped down `metal_stdlib` with apple branded alternatives such as `vec\u003cT, n\u003e` instead of `std::vector\u003cT\u003e`), etc.\n\nThis is meant to be a reference article for non-scientific projects. This article has been heavily simplified for performance and \"close enough\" approximations.\n\n## Interpolation\n\nIf you're here reading this, you probably know that _interpolation_ is used when you have a series of data, either through time or space, and you want to estimate the data between your data points. If X₀=0, Y₀=0 and X₂=2, Y₂=4, then X₁=1 means Y₁ probably equals 2. We can guess this because we can see the 2 values make up a line similar to Y=2X, or maybe it's Y=X^2. Who's to say? What's important is using the data we have around us to best-guess this.\n\n## Problem \u0026 Requirements before Interpolation\n\nMap Distortion and Scaling were unique to our project, however they may interest you in similar projects. These are not required for interpolation at all. These are for if you were planning on putting a view with an X/Y coordinate system on a map and these problems weren't handled for you.\n\n### Map Distortion\n\nOur data was given to us in a 2D space with an XY coordinate system, however it was not processed for distortion. To do that, I found these scary looking equations:\n\nx = R (λ - λ₀)\n\ny = R ln(tan(π/4 + θ/2))\n\nKey points that hopefully help:\n\n- R is the radius of the given sphere (6378137.0 meters, according to the WGS 1984 semimajor axis. I don't know what this means, it's just important)\n\n- λ₀ is the central meridian (for the Mercator projection as we're using, this is 0.0˚ longitude)\n\n- λ is the longitude in degrees (for example: -79.876884˚)\n\n- θ is the latitude in degrees (for example: 32.808445˚)\n\nThe following example is given in Metal and Python:\n\n#### Metal\n\n```c++\n// We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n// This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\nfloat2 longLatToXY(float2 coords) {\n    float radius = 6378137.0;\n    float centralMeridian = 0.0;\n    float pi_approx = 3.1415926;\n    float x = radius * (coords.x - centralMeridian);\n    float y = radius * log(tan((pi_approx / 4) + (coords.y / 2)));\n    // return in X/Y format, even though we passed in as LongLat\n    return float2(x, y);\n}\n```\n\n#### Python 3\n\n```python\nfrom numpy import log as ln\nfrom math import pi, tan\n\n# We use LongLat. We all know it as LatLong, but it is standard in math and mapping to use LongLat.\n# This is important for GIS, GeoJSON, MapBox, Google Maps, etc.\ndef longLatToXY(long: float, lat: float):\n    radius = 6378137.0\n    centralMeridian = 0.0\n    x = radius * (long - centralMeridian)\n    y = radius * ln(tan((pi / 4) + (lat / 2)))\n    # return in X/Y tuple format, even though we passed in as LongLat\n    return (x, y)\n```\n\nIf that sucks, skip it for now. I did.\n\n### Map scaling\n\nMaps are scaled on an often used zoom level of 0 to ~23. 0 means the map is zoomed all the way out and a single pixel represents several hundred/thousand miles of land, while zoom level ~23 means you could zoom into a blade of grass. This scaling is exponential, and thankfully the math is super easy. If you were to overlay a view of a known size perfectly over the map, the math would be as follows to make the view scale with the map:\n\n`scale = 2^(zoom_level)`\n\nThat's it! Now for code examples.\n\n#### Metal\n\n```c++\nfloat getMapScale(float zoomLevel) {\n    return pow(2.0, zoomLevel);\n}\n\n// Some arbitrary view size that fits perfectly over the map\nfloat2 screenWidthHeight = float2(300.0, 100.0);\n// Some arbitrary zoom level I choose. Get this from your map software/library.\nfloat zoomLevel = 4.6;\n\nfloat2 screenScaledWidthHeight = screenWidthHeight * getMapScale(zoomLevel);\n```\n\n#### Python 3\n\n```python\ndef getMapScale(zoom_level: float):\n    return pow(2, zoom_level)\n\n# Some arbitrary view size that fits perfectly over the map\nscreenWidth = 300\nscreenHeight = 100\n# Some arbitrary zoom level I choose. Get this from your map software/library.\nzoom_level = 4.6\n\nscale = getMapScale(zoom_level)\nscreenScaledWidth = scale * screenWidth\nscreenScaledHeight = scale * screenHeight\n```\n\n### Bilinear Interpolation\n\nFinally, we are handling interpolation. I don't know the exact name for this method, but I do know it is a form of bilinear interpolation (with a twist) that I accidentally made but then later found a ResearchGate post - by an actual scientist with a degree - that did the same method but significantly better. So I just copied the scientist's version and claimed it as my own, as is the engineering way.\n\nMy method of Bilinear Interpolation is regular Linear Interpolation, but its used a few times to get the values on the X axis and the Y axis separately and then together. The purpose of using Bilinear Interpolation here is because if I pick a position at random from within the view (with my 2D data overlayed) it is not going to be a clean whole number (or will be a whole number not in my evenly spaced data), so I will not have data for it. If I picked point (63.829, 12.236) but I only had data for (63, 12), (64, 12), (63, 13), (64, 13), I'd need to find what the data would be without making the visual have hard edges (aka just taking the data from the closest point [64, 12] until it gets closer to another point, creating a square around each point). That would look terrible.\n\nThe first thing you need to do is have an angle in degrees (example: 270˚). Radians work, I just don't want to explain how to do it in radians even though we're turning the angle into radians anyway. It's like 3am and I just want a drop-in method, sue me. If you want to turn your radians into degrees then do the following:\n\n`degrees = 180 / π`\n\nOnce you have your angle in degrees and a number value for your speed (miles per hour, kilometers per hour, meters per second, nautical miles per quarter-century, it doesn't matter, just get a number), we're going to break up our angle and speed into U/V values. U and V values are a way to flatten our circular angle into 2 sin/cosine lines that can be interpolated independently and rejoined. For that I have this code that might explain better:\n\n#### Metal\n\n```c++\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    float pi_approx = 3.1415926;\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n```\n\n#### Python 3\n\n```python\nfrom math import sin, cos, pi\n\ndef velocityToUVComponents(degrees: float, speed: float):\n    # To receive interpolatable rotational degrees, we must seperate the\n    # angle into it's U and V values. U and V are the values that would\n    # be graphed as X and Y values respectively\n    u = (-1 * speed) * sin(2 * pi * degrees / 360)\n    v = (-1 * speed) * cos(2 * pi * degrees / 360)\n    return (u, v)\n```\n\nand to go from UV values to degrees:\n\n#### Metal\n\n```c++\nfloat uvComponentstoVelocity(float2 uv) {\n    float pi_approx = 3.1415926;\n    // Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    // atan2(v, u) aka atan2(y, x) is the correct order\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n```\n\n#### Python 3\n\n```python\nfrom math import pi, atan2\n\ndef uvComponentsToVelocity(u: float, v: float):\n    # Despite what most sources will tell you about atan2, do NOT put atan2(u, v) aka atan2(x, y).\n    # atan2(v, u) aka atan2(y, x) is the correct order for this use case. Don't ask why, I don't know.\n    return (atan2(v, u) * 360 / 2 / pi) + 180\n```\n\nAs I said, the purpose of this is to interpolate these U and V values independently of each other. As an added bonus, the returning angles when we're finally done with this will always be between 0-360 and wrap around appropriately. What's so special about that? Have you tried averaging 1˚ and 359˚? It comes out to 180˚ instead of 0˚ or 360˚, which is wrong. U and V values are also good if you want to find just the simple average between two angles, which is the first step of interpolation!\n\nBefore continuing, please note that in Metal I'm passing around a pointer to a 1D array (representing a flat 2D array for Swift\u003c-\u003eMetal compatibility) array of `WindGridPoint` values called `WindGridPoint *windGrid`. `WindGridPoint` is described below:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridPoint {\n    vector_float2 position;\n    float speed;\n    uint angle;\n};\n```\n\nThat is all the data I have for every point on the grid. Before I continue, I first want to mention that if you are following my example of passing around a 1D array representing a 2D array (not recommended but its easier), you need to know the size of the grid ahead of time or pass in another object like above called `WindGridInfo`:\n\n#### Objective-C\n\n```objective-c\n// This is in an Objective-C header (.h) file so that I can use the struct in both Swift and Metal.\n// You will need to add a simple Bridging-Header file to do this.\nstruct WindGridInfo {\n    uint width;\n    uint height;\n    uint screenWidth;\n    uint screenHeight;\n};\n```\n\nNow we can use this object to map over a 1D array as if it were a 2D array:\n\n#### Swift\n\n```swift\n// Renderer.swift\nlet info: WindGridInfo = WindGridInfo(\n    width: 300,     // number of data points on the X axis\n    height: 100,    // number of data points on the Y axis\n    screenWidth: self.view.currentDrawable.width,\n    screenHeight: self.view.currentDrawable.height\n)\n// Now pass this into your Metal pipeline\n```\n\n#### Metal\n\n```c++\n// Shaders.metal\n\nuint arr2DtoArr1D (uint x, uint y, WindGridInfo *info) {\n    return x + (y * info.width);\n}\n\n// A Vertex Pipeline that takes and executes our data from Swift. Can also be a Compute or any other pipeline type.\nvertex VertexOut vertexShader(\n  device Particle *particleArray [[buffer(0)]],\n  const device WindGridPoint *windGridPoints [[buffer(1)]],\n  const device WindGridInfo *windGridInfo [[buffer(2)]],\n  unsigned int vid [[vertex_id]]\n) {\n    // particleArray is our array of particles on the screen\n    // windGridPoints is the data for the grid\n    // * windGridInfo is what we just created that stores our grid information *\n    // vid is the index of the particleArray\n\n    WindGridInfo* info = windGridInfo;\n    uint dataPointX = 32;\n    uint dataPointY = 61;\n    uint dataPointIndex = arr2DtoArr1D(dataPointX, dataPointY, info);\n    WindGridPoint neededPoint = windGridPoints[dataPointIndex];\n}\n```\n\nThat's how I look up a data point from a properly ordered array!\n\nThe next step is described by the `getUVsOfRelativePosition` function below. What we are doing is making a square around the arbitrary point and getting the data from the 4 nearest points that create a square. For each of those points, we would use the `getUVsOfAbsolutePosition` function to get the data for that point. `getUVsOfAbsolutePosition` is using the method described above in regards to indexing a flattened 2D array.\n\nOne more note: I now use a float3 for UV values to include the speed as a z value. The \"degrees to UV code\" above has changed.\n\nThe full code for the bilinear interpolation functions for Metal, including the UV components, are below\n\n#### Metal\n\n```c++\n# define pi_approx 3.1415926\n\nfloat2 velocityToUVComponents(int degrees, float speed) {\n    // To receive interpolatable rotational degrees, we must seperate the\n    // angle into it's U and V values. U and V are the values that would\n    // be graphed as X and Y values respectively\n    float u = -speed * sin(2 * pi_approx * degrees / 360);\n    float v = -speed * cos(2 * pi_approx * degrees / 360);\n    return float2(u,v);\n}\n\nfloat uvComponentstoVelocity(float3 uvs) {\n    return (atan2(uvs.y, uvs.x) * 360 / 2 / pi_approx) + 180;\n}\n\nfloat3 getUVsOfAbsolutePosition(int2 position, const device WindGridPoint *windGrid) {\n    // Get UV of a known point\n    WindGridPoint data_point = windGrid[int(position.x) + (127 * int(position.y))];\n    float2 uv = velocityToUVComponents(data_point.angle - 90, data_point.speed);\n    return float3(uv.x, uv.y, data_point.speed);\n}\n\nfloat4x3 getUVsOfRelativePosition(float4 positions, const device WindGridPoint *windGrid) {\n    // Get the values of the surrounding 4 corner coordinates\n    // Values are returned as UV values, described in uvComponents function\n    int lowX = positions[0];\n    int lowY = positions[1];\n    int highX = positions[2];\n    int highY = positions[3];\n    float3 tl_uvs = getUVsOfAbsolutePosition(int2(lowX, lowY), windGrid);    // Top Left Coord;      Relative 0,0\n    float3 tr_uvs = getUVsOfAbsolutePosition(int2(highX, lowY), windGrid);    // Top Right Coord;     Relative 1,0\n    float3 bl_uvs = getUVsOfAbsolutePosition(int2(lowX, highY), windGrid);    // Bottom Left Coord;   Relative 0,1\n    float3 br_uvs = getUVsOfAbsolutePosition(int2(highX, highY), windGrid); // Bottom Right Coord;  Relative 1,1\n\n    return float4x3(tl_uvs, tr_uvs, bl_uvs, br_uvs);\n}\n\nfloat3 interpolateVelocity(float2 position, const device WindGridPoint *windGrid) {\n    // position is the adjusted position to fit the grid. X is 0-127, Y is 0-68\n\n    float lowX = floor(position.x);\n    float lowY = floor(position.y);\n    float highX = ceil(position.x);\n    float highY = ceil(position.y);\n\n    float4x3 uvs = getUVsOfRelativePosition(float4(lowX, lowY, highX, highY), windGrid);\n\n    float3 topLeftUVS = uvs[0];      // 0,0\n    float3 topRightUVS = uvs[1];     // 1,0\n    float3 bottomLeftUVS = uvs[2];   // 0,1\n    float3 bottomRightUVS = uvs[3];  // 1,1\n    const uint U = 0; // U value\n    const uint V = 1; // V value\n    const uint S = 2; // Speed value\n\n    // Interpolate U values\n    // x with y1\n    float lowerXU1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[U];\n    float lowerXU2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[U];\n    float lowerXU = lowerXU1 + lowerXU2;\n    // x with y2\n    float upperXU1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[U];\n    float upperXU2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[U];\n    float upperXU = upperXU1 + upperXU2;\n    // y with interpolated x\n    float yU1 = ((highY - position.y) / (highY - lowY)) * lowerXU;\n    float yU2 = ((position.y - highY) / (highY - lowY)) * upperXU;\n    float yU = yU1 + yU2;\n\n    // Repeat the same interpolation on the V values\n    // x with y1\n    float lowerXV1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[V];\n    float lowerXV2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[V];\n    float lowerXV = lowerXV1 + lowerXV2;\n    // x with y2\n    float upperXV1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[V];\n    float upperXV2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[V];\n    float upperXV = upperXV1 + upperXV2;\n    // y with interpolated x\n    float yV1 = ((highY - position.y) / (highY - lowY)) * lowerXV;\n    float yV2 = ((position.y - highY) / (highY - lowY)) * upperXV;\n    float yV = yV1 + yV2;\n\n    // Repeat the same interpolation on the Speed\n    // x with y1\n    float lowerXS1 = ((highX - position.x) / (highX - lowX)) * topLeftUVS[S];\n    float lowerXS2 = ((position.x - lowX) / (highX - lowX)) * topRightUVS[S];\n    float lowerXS = lowerXS1 + lowerXS2;\n    // x with y2\n    float upperXS1 = ((highX - position.x) / (highX - lowX)) * bottomLeftUVS[S];\n    float upperXS2 = ((position.x - lowX) / (highX - lowX)) * bottomRightUVS[S];\n    float upperXS = upperXS1 + upperXS2;\n    // y with interpolated x\n    float yS1 = ((highY - position.y) / (highY - lowY)) * lowerXS;\n    float yS2 = ((position.y - highY) / (highY - lowY)) * upperXS;\n    float yS = abs(yS1) + abs(yS2);\n\n    float3 resUVS = float3(yU, yV, yS);\n    float resultDirection = uvComponentstoVelocity(resUVS);\n    return float2(resultDirection, resUVS.z);\n}\n```\n\nNow we can just call `interpolateVelocity` with an arbitrary point within our grid and we have our rotation in degrees as our X and our speed as our Y.\n\n#### Metal\n\n```c++\n// Get these from the buffer:\nWindGridPoint* windGridPointArr = windGridPoints\nWindGridInfo* info = windGridInfo;\n\n// Separated for clarity\nfloat arbitraryX = 38.382921;\nfloat arbitraryY = 71.881391;\nfloat2 arbitraryPosition = float2(arbitraryX, arbitraryY);\nfloat2 directionAndSpeed = interpolateVelocity(arbitraryPosition, windGridPointArr);\nfloat directionInDegrees = directionAndSpeed.x;\nfloat speed = directionAndSpeed.y;\n```\n\nThat's it! Email me at [brad@bread.codes](mailto://brad@bread.codes) if you have any questions or want to raise concerns about the efficacy of my work.","categories":["data","algorithms"],"skeets":[]}]},"__N_SSG":true},"page":"/archive","query":{},"buildId":"Ya4gzTM6YUh04oFuJ6rbS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>