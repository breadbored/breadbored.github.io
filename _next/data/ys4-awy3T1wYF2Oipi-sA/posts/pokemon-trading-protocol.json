{"pageProps":{"post":{"title":"Pokemon Trading Protocol","date":"2025-01-01","slug":"pokemon-trading-protocol","excerpt":"I originally posted a breakdown of how trading in Pokémon Red, Blue, and Yellow works as a thread on BlueSky, but I wanted to share it here with additional supporting information (and corrections, becuase it had been over a year since I touched this project when I posted it). Hopefully you enjoy!","content":"I originally posted a breakdown of how trading in Pokémon Red, Blue, and Yellow works as a thread on BlueSky, but I wanted to share it here with additional supporting information (and corrections, becuase it had been over a year since I touched this project when I posted it). Hopefully you enjoy!\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbj7tk2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnk2m\n\nLike I said, the GB/C link cable is bastard of SPI. Below is the pinout of the port\n\n```text\n    _________   1 -> 5v\n   / 1  2  3 \\  2 -> RX\n  /           \\ 3 -> CLK\n  |           | 4 -> TX\n  |  4  5  6  | 5 -> Unused\n  +-----------+ 6 -> GND\n\n* 5v: +5 Volt Power\n* RX: Receive Data\n* CLK: Clock In/Out (Slave/Master respectively)\n* TX: Transmit Data\n* Unused: A reserved pin\n* GND: Ground\n```\n\nYou may notice Chip Select is missing. Since the Game Boy only expects to have one master and one slave, so it's not needed for switching between multiple slave devices. \n\nIf you are unfamiliar with serial transfers, you may also notice two pins are for receiving and sending respectively. They are typically wired like so:\n\n```text\n  Master        Slave\n  | TX --------> RX |\n  | RX <-------- TX |\n```\n\nThis is to trade data at the same time each clock cycle. The master will send the next byte while the slave responds to the previous byte. This ***would*** create a way to perform an optimistic trade where the master assumes the slave has a successful response while it continues to send data until told otherwise, but the Pokémon games send a filler byte between transfers while they wait for a response. These filler bytes will be talked about later, but keep them in mind.\n\nAdditionally, the Game Boy is active low, meaning that the clock is normally high and goes low when data is being sent. This is important to know when you are trying to send and read data using a microcontroller.\n\nThat is basically all we need to know about the hardware, as this is really about the program that drives this. Connecting to the Game Boy with other hardware may require a minor amount of work to implement this SPI-clone, but beyond that, it is basically unnecessary. My implementation runs on the Game Boy as a homebrew program, so I rely on the hardware to handle shifting data out and in.\n\nFrom this point forward we will mostly only be talking about the firmeware/software, specifically the `handle_byte` function that is called every time the slave receives a byte, which sends a byte back.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnl2m\n\nThis \"pecking order\" is literally just both Game Boys sending \"I'm master\" signals (`0x01`) to each other until the other submits and agknowledges itself as slave (`0x02`). Once they both agree to the arrangement with `0x60`, the Game Boys know their place and can start driving the trade.\n\n***I incorrectly stated on BSky that this is how they decide who drives the clock***. You don't need to be master to drive the clock. The clock-driver is decided by the hardware, and if CLK is held LOW, the hardware sets itself as the \"hardware slave.\" The \"software slave\" is the one that submits the `0x02` signal.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnm2m\n\nWhat I mean by this is that we don't want to be the \"hardware master.\" This ensures that we aren't going too fast for the actual game, and it will let us know when it's ready to continue.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnn2m\n\nWhen the master sends us an ACK (acknowledgement) signal (`0x00`), we usually respond with a `0x00`\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhno2m\n\nIt is entirely possible to be the hardware master, but this was far faster than arbitrary delays to give the game time to ready its response. \n\nThis is also my memory failing me, and conflating software and hardware roles.\n\n---\n\nAbove this point we have been talking entirely about how the hardware roles are decided and how the software roles are decided. The software roles are almost entirely handled by this section of code:\n\n```c\nuint8_t handle_byte(uint8_t in, uint8_t *out) {\n    // ...\n    switch (connection_state) { // enum holding the state of the connection\n        case NOT_CONNECTED:\n            switch (in)\n            {\n                // The other is the master\n                case PKMN_MASTER: // 0x01\n                    out[0] = PKMN_SLAVE; // 0x02\n                    break;\n                case PKMN_BLANK: // 0x00\n                    out[0] = PKMN_BLANK; // 0x00\n                    break;\n                case PKMN_CONNECTED: // 0x60\n                    connection_state = CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_CONNECTED; // 0x60\n                    break;\n            }\n            break;\n\n        // case ...\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnp2m\n\nOnce the above switch statement has concluded that the connection is established, we wait for the game to send us the TRADE_CENTER (`0xD4`) signal to say they are at the counter and are preparing to enter the trade room. Here is the code for this section\n\n```c\nuint8_t handle_byte(uint8_t in, uint8_t *out) {\n    // ...\n    switch (connection_state) { // enum holding the state of the connection\n        // case ...\n\n        case CONNECTED:\n            switch (in)\n            {\n                case PKMN_CONNECTED: // 0x60\n                    out[0] = PKMN_CONNECTED; // 0x60\n                    break;\n                case PKMN_TRADE_CENTER: // 0xD4\n                    // No byte response known; just move on the next case (we'll discuss later)\n                    connection_state = TRADE_CENTER; // enum holding the state of the connection\n                    break;\n                case PKMN_COLOSSEUM: // 0xD5\n                    // We're not implementing this so just break the link\n                    connection_state = NOT_CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_BREAK_LINK; // 0xD6\n                    break;\n                case PKMN_BREAK_LINK: // 0xD6\n                case PKMN_MASTER: // 0x01\n                    connection_state = NOT_CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_BREAK_LINK; // 0xD6\n                    break;\n                \n                // By default, these are just filler bytes, so just echo them back to the master\n                default:\n                    out[0] = in; // echo back the byte\n                    break;\n            }\n            break;\n\n        case TRADE_CENTER:\n            // Protocol for the trade center\n            // ...\n            break;\n        \n        // case ...\n\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjimx2m\n\nLet's derail this train...\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjjm72m\n\nHere is the exceprt of the Trade Center packet:\n\n```c\ntypedef struct TraderPacket {\n    // Name must not exceed 10 characters + 1 STOP_BYTE\n    // Any leftover space must be filled with STOP_BYTE (actually I'm not sure that's true, but you should do it)\n    unsigned char name[11];\n    struct SelectedPokemon selected_pokemon;\n    struct PartyMember pokemon[6];\n    unsigned char original_trainer_names[6][11];\n    unsigned char pokemon_nicknames[6][11];\n} TraderPacket;\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdcok6h2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdcouw72m\n\n```c\ntypedef struct PartyMember {\n    enum gen_one_dex_t pokemon;\n    uint16_t current_hp;\n    uint16_t max_hp;\n    uint8_t level;\n    enum status_condition_t status;\n    enum poke_type_t type1;\n    enum poke_type_t type2; // If only one type, copy the first\n    uint8_t catch_rate_or_held_item; // R/G/B/Y (catch rate), G/S/C (held item), and Stadium (held item) use this byte differently\n    enum poke_move_t move1;\n    enum poke_move_t move2;\n    enum poke_move_t move3;\n    enum poke_move_t move4;\n    uint16_t original_trainer_id; // In decimal, these are the funny numbers\n\n    // -   Experience is complicated. You must look up the Pokemon you are trying to trade\n    //      in the following table and apply the experience points that match the level.\n    //      EXP LVL Table for gen 1: https://pwo-wiki.info/index.php/Generation_I_Experience_Charts\n    //      That source was the best I could find for Gen 1. If you find another, submit a PR or open an issue and I'll fix it\n    // -   Experience is a 24bit number, we will be dropping the MSB to acheive that\n    uint32_t experience;\n\n    // Effort Values\n    // These are very specific to the Pokemon and who they battled in the past or what vitamins they were fed\n    // Luckily, these get recalculated when you level them up, or when you put them in a box and then put them back in your party\n    // For this example, I will take the max value and scale it to the level (65535 * 0.40) = 26214\n    uint16_t HP_ev;\n    uint16_t attack_ev;\n    uint16_t defense_ev;\n    uint16_t speed_ev;\n    uint16_t special_ev;\n\n    // IVs are a 4 bit number, so the max value is 15 (0-15 = 0b0000-0b1111 = 0x0-0xF)\n    // These have been broken out for legibility, but will be condensed to only 2 bytes\n    uint8_t attack_iv;\n    uint8_t defense_iv;\n    uint8_t speed_iv;\n    uint8_t special_iv;\n\n    uint8_t move1_pp;\n    uint8_t move2_pp;\n    uint8_t move3_pp;\n    uint8_t move4_pp;\n\n    uint16_t attack;\n    uint16_t defense;\n    uint16_t speed;\n    uint16_t special;\n} PartyMember;\n```\n\nWhich is serialized like so:\n\n```c\nstruct PartyMember *pPartyMember = &traderPacket.pokemon[i];\npPartyMember->pokemon = MEW;\npPartyMember->current_hp = 100;\npPartyMember->max_hp = 130;\npPartyMember->level = 40;\npPartyMember->status = NONE;\npPartyMember->type1 = PSYCHIC_TYPE;\npPartyMember->type2 = PSYCHIC_TYPE; // If only one type, copy the first\npPartyMember->catch_rate_or_held_item = 0xFF; // R/G/B/Y (catch rate), G/S/C (held item), and Stadium (held item) use this byte differently\npPartyMember->move1 = TELEPORT;\npPartyMember->move2 = PSYWAVE;\npPartyMember->move3 = PSYCHIC;\npPartyMember->move4 = FLY;\npPartyMember->original_trainer_id = 0xA455; // In decimal, these are the funny numbers\n\n// -   Experience is complicated. You must look up the Pokemon you are trying to trade\n//      in the following table and apply the experience points that match the level.\n//      EXP LVL Table for gen 1: https://pwo-wiki.info/index.php/Generation_I_Experience_Charts\n//      That source was the best I could find for Gen 1. If you find another, submit a PR or open an issue and I'll fix it\n// -   Experience is a 24bit number, we will be dropping the MSB to acheive that\npPartyMember->experience = 190148;\n\n// Effort Values\n// These are very specific to the Pokemon and who they battled in the past or what vitamins they were fed\n// Luckily, these get recalculated when you level them up, or when you put them in a box and then put them back in your party\n// For this example, I will take the max value and scale it to the level (65535 * 0.40) = 26214\npPartyMember->HP_ev = 26214;\npPartyMember->attack_ev = 26214;\npPartyMember->defense_ev = 26214;\npPartyMember->speed_ev = 26214;\npPartyMember->special_ev = 26214;\n\n// IVs are a 4 bit number, so the max value is 15 (0-15 = 0b0000-0b1111 = 0x0-0xF)\n// These have been broken out for legibility, but will be condensed to only 2 bytes\npPartyMember->attack_iv = 0xF;\npPartyMember->defense_iv = 0xF;\npPartyMember->speed_iv = 0xF;\npPartyMember->special_iv = 0xF;\n\npPartyMember->move1_pp = 20;\npPartyMember->move2_pp = 15;\npPartyMember->move3_pp = 10;\npPartyMember->move4_pp = 15;\n\npPartyMember->attack = 100;\npPartyMember->defense = 100;\npPartyMember->speed = 100;\npPartyMember->special = 100;\n```\n\nand deserialized like so:\n\n```c\nvoid party_member_to_bytes(struct PartyMember *pPartyMember, uint8_t *out) {\n    uint8_t res[44] = {\n        pPartyMember->pokemon,\n        (uint8_t) (pPartyMember->current_hp >> 8),\n        (uint8_t) (pPartyMember->current_hp & 0x00FF),\n        pPartyMember->level,\n        pPartyMember->status,\n        pPartyMember->type1,\n        pPartyMember->type2,\n        pPartyMember->catch_rate_or_held_item,\n        pPartyMember->move1,\n        pPartyMember->move2,\n        pPartyMember->move3,\n        pPartyMember->move4,\n        (uint8_t) (pPartyMember->original_trainer_id >> 8),\n        (uint8_t) (pPartyMember->original_trainer_id & 0x00FF),\n        (uint8_t) ((pPartyMember->experience & 0x00FF0000) >> 16),\n        (uint8_t) ((pPartyMember->experience & 0x0000FF00) >> 8),\n        (uint8_t) (pPartyMember->experience & 0x000000FF),\n        (uint8_t) (pPartyMember->HP_ev >> 8),\n        (uint8_t) (pPartyMember->HP_ev & 0x00FF),\n        (uint8_t) (pPartyMember->attack_ev >> 8),\n        (uint8_t) (pPartyMember->attack_ev & 0x00FF),\n        (uint8_t) (pPartyMember->defense_ev >> 8),\n        (uint8_t) (pPartyMember->defense_ev & 0x00FF),\n        (uint8_t) (pPartyMember->speed_ev >> 8),\n        (uint8_t) (pPartyMember->speed_ev & 0x00FF),\n        (uint8_t) (pPartyMember->special_ev >> 8),\n        (uint8_t) (pPartyMember->special_ev & 0x00FF),\n        (uint8_t) (((pPartyMember->attack_iv & 0xF) << 4) | (pPartyMember->defense_iv & 0xF)),\n        (uint8_t) (((pPartyMember->speed_iv & 0xF) << 4) | (pPartyMember->special_iv & 0xF)),\n        pPartyMember->move1_pp,\n        pPartyMember->move2_pp,\n        pPartyMember->move3_pp,\n        pPartyMember->move4_pp,\n        pPartyMember->level,\n        (uint8_t) (pPartyMember->max_hp >> 8),\n        (uint8_t) (pPartyMember->max_hp & 0x00FF),\n        (uint8_t) (pPartyMember->attack >> 8),\n        (uint8_t) (pPartyMember->attack & 0x00FF),\n        (uint8_t) (pPartyMember->defense >> 8),\n        (uint8_t) (pPartyMember->defense & 0x00FF),\n        (uint8_t) (pPartyMember->speed >> 8),\n        (uint8_t) (pPartyMember->speed & 0x00FF),\n        (uint8_t) (pPartyMember->special >> 8),\n        (uint8_t) (pPartyMember->special & 0x00FF),\n    };\n    for (size_t i = 0; i < 44; i++) {\n        out[i] = res[i];\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegqyx2m\n\nMakes sense, right? Copying from SRAM / RAM is always going to be cheaper than restructuring data. I guess I should have guessed that.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegqyy2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegrya2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryb2m\n\nI just skipped over SO MUCH. I must've been tired when I wrote this BSky post, because it skips a major part of the protocol.\n\nSo, that `handle_byte` function I've been talking about before we derailed, it manages the state of the connection. We left off on this part:\n\n```c\ncase PKMN_TRADE_CENTER: // 0xD4\n    // No byte response known; just move on the next case (we'll discuss later)\n    connection_state = TRADE_CENTER; // enum holding the state of the connection\n    break;\n```\n\nYou may notice that it doesn't send a byte back to the master. It instead moves on to the next case, which is the `TRADE_CENTER` state. Instead of breaking down the code segments, which are long and illegible, I will explain the logic of the process.\n\n- When in doubt, echo back the input to the output\n    - If things get really bad, start the process over from the beginning\n- The Trade Center status is in its default state, `INIT`\n    - In this case, we are waiting for a `0x00` byte from the master\n    - We respond with `0x00` and move to the next state, `READY`\n- The TC status is in the `READY` state\n    - In this case, we are waiting for a `0xFD` byte from the master\n    - We respond with `0xFD` and move to the next state, `AGREED`\n- The TC status is in the `AGREED` state\n    - In this case, we are waiting for any byte that is ***NOT*** `0xFD` from the master\n    - We respond with `0xFD` and move to the next state, `ANY_IN`\n- The TC status is in the `ANY_IN` state\n    - ***We set a counter to 0 to count the number of bytes we receive***\n    - In this case, we are waiting for any byte from the master\n    - We respond with `0xFD` and move to the next state, `WAIT`\n- The TC status is in the `WAIT` state\n    - If we receive a `0xFD` byte\n        - ... we just respond with a `0x00` until we get a different response\n    - If we receive a byte that is ***NOT*** `0xFD` \n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n        - ***We set a counter to 0 to count the number of bytes we receive***\n        - We respond with the first byte of our TraderPacket we constructed from the struct earlier\n        - We add 1 to the counter\n        - We move to the next state, `TRANSFER`\n- The TC status is in the `TRANSFER` state\n    - In this case, we are waiting for any byte from the master\n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n    - We respond with the next byte of our TraderPacket we constructed from the struct earlier\n    - We add 1 to the counter\n    - If we have sent all 418 bytes, we move to the next state, `PATCH`\n        - Why 418? That's the size of the TraderPacket struct when we deserialized it\n- The TC status is in the `PATCH` state\n    - If we receive a `0xFD` byte from the master\n        - ***We set a counter to 0 to count the number of bytes we receive***\n        - We respond with `0xFD`\n    - If we receive a byte that is ***NOT*** `0xFD`\n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n        - We respond by echoing back whatever the master sends us\n        - We add 1 to the counter\n        - If we have sent 197 bytes, we move to the next state, `TRADE_WAIT`\n            - Why 197? Because that's how long the trade animation is, and this is just to see if we're still alive\n- The TC status is in the `TRADE_WAIT` state\n    - If we receive a byte that is `&` with `0x60` to equal `0x60`\n        - If we receive a `0x6f`, we respond with `0x6f` and move back to the `READY` state to start over\n        - If we receive a `0x60`, we respond with `0x60` and move to the next state, `TRADE_DONE`\n    - If we receive a `0x00` byte from the master\n        - We respond with `0x00`\n        - We move to the next state, `TRADE_DONE`\n- The TC status is in the `TRADE_DONE` state\n    - We are waiting for a byte from the master that can be `&` with `0x60` to equal `0x60`\n        - We always echo back this byte. We are just reading it to see what the status of the trade is\n        - If the byte is `0x61`, we go back to `TRADE_WAIT`\n        - Otherwise, we're `DONE`\n- The TC status is in the `DONE` state\n    - We are waiting for `0x00` from the master\n        - We respond with `0x00`\n        - We move back to the `INIT` state to start over\n\nHere are all the states and what they do:\n\n- `INIT`: Trade has started\n- `READY`: Both devices are ready to begin\n- `AGREED`: Both devices have agreed where to start\n- `ANY_IN`: Waiting for the master to send us data\n- `WAIT`: Waiting for the master to send us data\n- `TRANSFER`: Sending the TraderPacket to the master\n- `PATCH`: Waiting for the animation to finish\n- `TRADE_WAIT`: Waiting for the trade to finish\n- `TRADE_DONE`: Trade is done\n- `DONE`: Connection is done\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryc2m\n\nSomewhat in correct, please refer to my above correction\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryd2m\n\nSomewhat in correct, please refer to my above correction\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegtwt2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdermo32m\n\nOver a year ago, I was working on a YouTube video where I would explain how to counterfeit Pokemon through the trade protocol. Unfortunately, life happens, and I never got to share this the way I wanted to. You can follow @BreadCodes on YouTube if you want to see that kind of content!","categories":["pokemon","gameboy","game boy","retro-computing"],"skeets":[{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbj7tk2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbj7tk2m","text":"I was not the first person to do it, but I reverse engineered the Pokémon Gen 1 trading protocol some time ago\n\nI reminisce about this project often, so I thought I'd make a thread about how it works!\n\n#reverseengineering #retrogamedev #retrogaming #pokemon\n\n[1/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.054Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhnk2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhnk2m","text":"So the first thing to understand is that the Game Boy used a bastardized version of SPI for communication, just without the Chip Select line since the Game Boy could be connected to only one other device... but if that device is another Game Boy, who's in control of the clock?\n\n[2/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.055Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhnl2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhnl2m","text":"The quirky part of this is that they have a pecking order in Pokémon to decide who's in control. The first one to successfully send a byte becomes the Primary (formerly \"master\") and the receiver becomes the Secondary (formerly \"slave\")... how do you make this consistent?\n\n[3/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.056Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhnm2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhnm2m","text":"Well, you of course give up control, and you never send a byte until the other GB takes control. This is how I managed the state of the trades, because by always waiting for the other GB, the Primary always polled when ready. Now what?\n\n[4/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.057Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhnn2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhnn2m","text":"Well, the Primary sends packets to check if we're still there, which we acknowledge (0x00) in a response. You do this until the other GB reports that it is at a Pokémon Center and is at the link counter. When they are ready, we start the handshake process.\n\n[5/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.058Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhno2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhno2m","text":"Here's where the actual protocol starts.  Since we're the Secondary, we are being polled by the Primary so that we don't accidentally go too fast\n\nNow we say we are also at the link counter and want to trade.\n\n[6/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.059Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjhnp2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjhnp2m","text":"We wait for a READY (0xFD) and respond READY. We do it again... and again... and again, but this time we respond with a 0x00. I don't actually know why this was necessary 4 times.\n\nNow we are in a \"waiting\" state. This state is used to send our Pokemon in their entirety to the other GB.\n\n[7/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.060Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjimx2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjimx2m","text":"Here's where we take a detour from the protocol itself\n\nWe don't just send basic info about our 'mons, we send every byte of the Pokemon almost exactly as they would be in our party and some info about ourselves.\n\n[8/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.061Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdbjjm72m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdbjjm72m","text":"In short, here is the order of what we are sending:\n- Trainer Name (11 bytes, 0x50 terminated string [in English])\n- Selected Pokemon (1 byte for num of mons in party + 6 bytes each representing the mons' true ID)\n- Party Member (6 whole Pokemon, each 44 bytes [discussed later])\n\n[9/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.062Z","embed":{"$type":"app.bsky.embed.images","images":[{"alt":"A C code block showing the packet structure of a trade","aspectRatio":{"width":866,"height":386},"image_url":"/bsky/images/pokemon-trading-protocol-8-0.jpg"}]},"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdcok6h2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdcok6h2m","text":"[cont]\n- OG Trainer Names (an array containing 6 names, each 11 bytes long and 0x50 terminated [in english], with the same index as the party mons)\n- Mon Nicknames (^ read above note)\n\n[10/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.063Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdcouw72m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdcouw72m","text":"To explain how the mons are structured, here is the struct I made [left] and the function that turns the struct to an array of bytes (because I was using u32 for u24 numbers, u8 for nibbles, and the wrong endianness, it didn't align) [right]\n\nI wish I had space to explain this better\n\n[11/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.064Z","embed":{"$type":"app.bsky.embed.images","images":[{"alt":"A C code block showing the structure of Pokemon in Red, Blue, Green, Yellow. Note that there are comments in the code, which I will refer to, but will also explain","aspectRatio":{"width":1692,"height":2000},"image_url":"/bsky/images/pokemon-trading-protocol-10-0.jpg"},{"alt":"C code showing how the previous structure is converted to an array of bytes","aspectRatio":{"width":1587,"height":2000},"image_url":"/bsky/images/pokemon-trading-protocol-10-1.jpg"}]},"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegqyx2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegqyx2m","text":"For those who are not sight impaired (sorry for the poor alt text), you might be noticing my comments about how this matches the save file. Well, that's because Pokémon just copies your Pokémon directly from RAM and sends all of it over the wire.\n\n[12/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.065Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegqyy2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegqyy2m","text":"Interesting bits:\n- Mons can have 2 types, but if they don't, they usually have the same type twice\n- catch_rate_or_held_item is a byte that is different in Gen 1 & 2. Held items didn't exist until Gen 2, and they dropped catch rate because it was redundant\n\n[13/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.066Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegrya2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegrya2m","text":"[cont]\n- Experience is complicated math with several variables. I just used EXP calculators\n- EVs are 2 bytes long, but IVs are a nibble (4 bits / ½ byte)\n\nLet's get back to the protocol. Did you forget about it?\n\n[14/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.067Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegryb2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegryb2m","text":"We have sent our mons to each other after 197 messages. Now the Primary tells us it's status with a byte, which should have bits 5 and 6 set to high indicating it is ready. If it sends an ERROR (0x6f), we start over. Otherwise, bits 0-3 indicate the index of the mon it wants to trade.\n\n[15/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.068Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegryc2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegryc2m","text":"Since we are faking mons on the Secondary, we can send whatever we want, I just fill my party with Mews while we're trading info, and send index 0 (status 0x60) when it's time.\n\nOnce we have responded with this status, the trade has started.\n\n[16/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.069Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegryd2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegryd2m","text":"The Primary sends 0x00, we respond with 0x00, and we repeat until the animation is done.\n\nAfter that? We're done! We *should* restart the process and have some handling for trading again, but this is where I end my explanation.\n\n[17/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.070Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdegtwt2m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdegtwt2m","text":"Thank you to #GBDK (gbdk-2020) (and @bbbbbr.bsky.social as a major maintainer, please follow them) for enabling my project\nThank you to Bulbapedia and it's maintainers for documenting the Party and Bill's PC Pokémon data structure\nThank you for reading! lmk if you like this type of content\n\n[18/18]","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.071Z","embed":null,"indexedAt":null},{"url":"https://bsky.app/profile/bread.codes/post/3lcrkdermo32m","uri":"at://did:plc:mkvb2iguo4rjzi4guolw7bbt/app.bsky.feed.post/3lcrkdermo32m","text":"Fun tidbits:\n\nI accidentally found a way to destroy someone's save file. A real GB virus by corrupting the mon just right.\n\nI originally did this on a Pi, but decided that the barrier for others doing this was too high. I ended up rewriting this for the GB to be run from a flash cartridge","author":{"did":"did:plc:mkvb2iguo4rjzi4guolw7bbt","handle":"bread.codes","displayName":"bread","avatar":"https://cdn.bsky.app/img/avatar/plain/did:plc:mkvb2iguo4rjzi4guolw7bbt/bafkreiaorwyx5pdf7tmsbfmnt5ralz55sa3qhzkdtzj2ywbz26ao6zwdpm@jpeg"},"createdAt":"2024-12-08T06:08:09.072Z","embed":null,"indexedAt":null}]}},"__N_SSG":true}