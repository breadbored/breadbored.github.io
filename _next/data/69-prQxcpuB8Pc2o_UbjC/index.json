{"pageProps":{"posts":[{"title":"Pokemon Trading Protocol","date":"2025-01-01","slug":"pokemon-trading-protocol","excerpt":"I originally posted a breakdown of how trading in Pokémon Red, Blue, and Yellow works as a thread on BlueSky, but I wanted to share it here with additional supporting information (and corrections, becuase it had been over a year since I touched this project when I posted it). Hopefully you enjoy!","content":"I originally posted a breakdown of how trading in Pokémon Red, Blue, and Yellow works as a thread on BlueSky, but I wanted to share it here with additional supporting information (and corrections, becuase it had been over a year since I touched this project when I posted it). Hopefully you enjoy!\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbj7tk2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnk2m\n\nLike I said, the GB/C link cable is bastard of SPI. Below is the pinout of the port\n\n```text\n    _________   1 -> 5v\n   / 1  2  3 \\  2 -> RX\n  /           \\ 3 -> CLK\n  |           | 4 -> TX\n  |  4  5  6  | 5 -> Unused\n  +-----------+ 6 -> GND\n\n* 5v: +5 Volt Power\n* RX: Receive Data\n* CLK: Clock In/Out (Slave/Master respectively)\n* TX: Transmit Data\n* Unused: A reserved pin\n* GND: Ground\n```\n\nYou may notice Chip Select is missing. Since the Game Boy only expects to have one master and one slave, so it's not needed for switching between multiple slave devices. \n\nIf you are unfamiliar with serial transfers, you may also notice two pins are for receiving and sending respectively. They are typically wired like so:\n\n```text\n  Master        Slave\n  | TX --------> RX |\n  | RX <-------- TX |\n```\n\nThis is to trade data at the same time each clock cycle. The master will send the next byte while the slave responds to the previous byte. This ***would*** create a way to perform an optimistic trade where the master assumes the slave has a successful response while it continues to send data until told otherwise, but the Pokémon games send a filler byte between transfers while they wait for a response. These filler bytes will be talked about later, but keep them in mind.\n\nAdditionally, the Game Boy is active low, meaning that the clock is normally high and goes low when data is being sent. This is important to know when you are trying to send and read data using a microcontroller.\n\nThat is basically all we need to know about the hardware, as this is really about the program that drives this. Connecting to the Game Boy with other hardware may require a minor amount of work to implement this SPI-clone, but beyond that, it is basically unnecessary. My implementation runs on the Game Boy as a homebrew program, so I rely on the hardware to handle shifting data out and in.\n\nFrom this point forward we will mostly only be talking about the firmeware/software, specifically the `handle_byte` function that is called every time the slave receives a byte, which sends a byte back.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnl2m\n\nThis \"pecking order\" is literally just both Game Boys sending \"I'm master\" signals (`0x01`) to each other until the other submits and agknowledges itself as slave (`0x02`). Once they both agree to the arrangement with `0x60`, the Game Boys know their place and can start driving the trade.\n\n***I incorrectly stated on BSky that this is how they decide who drives the clock***. You don't need to be master to drive the clock. The clock-driver is decided by the hardware, and if CLK is held LOW, the hardware sets itself as the \"hardware slave.\" The \"software slave\" is the one that submits the `0x02` signal.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnm2m\n\nWhat I mean by this is that we don't want to be the \"hardware master.\" This ensures that we aren't going too fast for the actual game, and it will let us know when it's ready to continue.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnn2m\n\nWhen the master sends us an ACK (acknowledgement) signal (`0x00`), we usually respond with a `0x00`\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhno2m\n\nIt is entirely possible to be the hardware master, but this was far faster than arbitrary delays to give the game time to ready its response. \n\nThis is also my memory failing me, and conflating software and hardware roles.\n\n---\n\nAbove this point we have been talking entirely about how the hardware roles are decided and how the software roles are decided. The software roles are almost entirely handled by this section of code:\n\n```c\nuint8_t handle_byte(uint8_t in, uint8_t *out) {\n    // ...\n    switch (connection_state) { // enum holding the state of the connection\n        case NOT_CONNECTED:\n            switch (in)\n            {\n                // The other is the master\n                case PKMN_MASTER: // 0x01\n                    out[0] = PKMN_SLAVE; // 0x02\n                    break;\n                case PKMN_BLANK: // 0x00\n                    out[0] = PKMN_BLANK; // 0x00\n                    break;\n                case PKMN_CONNECTED: // 0x60\n                    connection_state = CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_CONNECTED; // 0x60\n                    break;\n            }\n            break;\n\n        // case ...\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjhnp2m\n\nOnce the above switch statement has concluded that the connection is established, we wait for the game to send us the TRADE_CENTER (`0xD4`) signal to say they are at the counter and are preparing to enter the trade room. Here is the code for this section\n\n```c\nuint8_t handle_byte(uint8_t in, uint8_t *out) {\n    // ...\n    switch (connection_state) { // enum holding the state of the connection\n        // case ...\n\n        case CONNECTED:\n            switch (in)\n            {\n                case PKMN_CONNECTED: // 0x60\n                    out[0] = PKMN_CONNECTED; // 0x60\n                    break;\n                case PKMN_TRADE_CENTER: // 0xD4\n                    // No byte response known; just move on the next case (we'll discuss later)\n                    connection_state = TRADE_CENTER; // enum holding the state of the connection\n                    break;\n                case PKMN_COLOSSEUM: // 0xD5\n                    // We're not implementing this so just break the link\n                    connection_state = NOT_CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_BREAK_LINK; // 0xD6\n                    break;\n                case PKMN_BREAK_LINK: // 0xD6\n                case PKMN_MASTER: // 0x01\n                    connection_state = NOT_CONNECTED; // enum holding the state of the connection\n                    out[0] = PKMN_BREAK_LINK; // 0xD6\n                    break;\n                \n                // By default, these are just filler bytes, so just echo them back to the master\n                default:\n                    out[0] = in; // echo back the byte\n                    break;\n            }\n            break;\n\n        case TRADE_CENTER:\n            // Protocol for the trade center\n            // ...\n            break;\n        \n        // case ...\n\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjimx2m\n\nLet's derail this train...\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdbjjm72m\n\nHere is the exceprt of the Trade Center packet:\n\n```c\ntypedef struct TraderPacket {\n    // Name must not exceed 10 characters + 1 STOP_BYTE\n    // Any leftover space must be filled with STOP_BYTE (actually I'm not sure that's true, but you should do it)\n    unsigned char name[11];\n    struct SelectedPokemon selected_pokemon;\n    struct PartyMember pokemon[6];\n    unsigned char original_trainer_names[6][11];\n    unsigned char pokemon_nicknames[6][11];\n} TraderPacket;\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdcok6h2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdcouw72m\n\n```c\ntypedef struct PartyMember {\n    enum gen_one_dex_t pokemon;\n    uint16_t current_hp;\n    uint16_t max_hp;\n    uint8_t level;\n    enum status_condition_t status;\n    enum poke_type_t type1;\n    enum poke_type_t type2; // If only one type, copy the first\n    uint8_t catch_rate_or_held_item; // R/G/B/Y (catch rate), G/S/C (held item), and Stadium (held item) use this byte differently\n    enum poke_move_t move1;\n    enum poke_move_t move2;\n    enum poke_move_t move3;\n    enum poke_move_t move4;\n    uint16_t original_trainer_id; // In decimal, these are the funny numbers\n\n    // -   Experience is complicated. You must look up the Pokemon you are trying to trade\n    //      in the following table and apply the experience points that match the level.\n    //      EXP LVL Table for gen 1: https://pwo-wiki.info/index.php/Generation_I_Experience_Charts\n    //      That source was the best I could find for Gen 1. If you find another, submit a PR or open an issue and I'll fix it\n    // -   Experience is a 24bit number, we will be dropping the MSB to acheive that\n    uint32_t experience;\n\n    // Effort Values\n    // These are very specific to the Pokemon and who they battled in the past or what vitamins they were fed\n    // Luckily, these get recalculated when you level them up, or when you put them in a box and then put them back in your party\n    // For this example, I will take the max value and scale it to the level (65535 * 0.40) = 26214\n    uint16_t HP_ev;\n    uint16_t attack_ev;\n    uint16_t defense_ev;\n    uint16_t speed_ev;\n    uint16_t special_ev;\n\n    // IVs are a 4 bit number, so the max value is 15 (0-15 = 0b0000-0b1111 = 0x0-0xF)\n    // These have been broken out for legibility, but will be condensed to only 2 bytes\n    uint8_t attack_iv;\n    uint8_t defense_iv;\n    uint8_t speed_iv;\n    uint8_t special_iv;\n\n    uint8_t move1_pp;\n    uint8_t move2_pp;\n    uint8_t move3_pp;\n    uint8_t move4_pp;\n\n    uint16_t attack;\n    uint16_t defense;\n    uint16_t speed;\n    uint16_t special;\n} PartyMember;\n```\n\nWhich is serialized like so:\n\n```c\nstruct PartyMember *pPartyMember = &traderPacket.pokemon[i];\npPartyMember->pokemon = MEW;\npPartyMember->current_hp = 100;\npPartyMember->max_hp = 130;\npPartyMember->level = 40;\npPartyMember->status = NONE;\npPartyMember->type1 = PSYCHIC_TYPE;\npPartyMember->type2 = PSYCHIC_TYPE; // If only one type, copy the first\npPartyMember->catch_rate_or_held_item = 0xFF; // R/G/B/Y (catch rate), G/S/C (held item), and Stadium (held item) use this byte differently\npPartyMember->move1 = TELEPORT;\npPartyMember->move2 = PSYWAVE;\npPartyMember->move3 = PSYCHIC;\npPartyMember->move4 = FLY;\npPartyMember->original_trainer_id = 0xA455; // In decimal, these are the funny numbers\n\n// -   Experience is complicated. You must look up the Pokemon you are trying to trade\n//      in the following table and apply the experience points that match the level.\n//      EXP LVL Table for gen 1: https://pwo-wiki.info/index.php/Generation_I_Experience_Charts\n//      That source was the best I could find for Gen 1. If you find another, submit a PR or open an issue and I'll fix it\n// -   Experience is a 24bit number, we will be dropping the MSB to acheive that\npPartyMember->experience = 190148;\n\n// Effort Values\n// These are very specific to the Pokemon and who they battled in the past or what vitamins they were fed\n// Luckily, these get recalculated when you level them up, or when you put them in a box and then put them back in your party\n// For this example, I will take the max value and scale it to the level (65535 * 0.40) = 26214\npPartyMember->HP_ev = 26214;\npPartyMember->attack_ev = 26214;\npPartyMember->defense_ev = 26214;\npPartyMember->speed_ev = 26214;\npPartyMember->special_ev = 26214;\n\n// IVs are a 4 bit number, so the max value is 15 (0-15 = 0b0000-0b1111 = 0x0-0xF)\n// These have been broken out for legibility, but will be condensed to only 2 bytes\npPartyMember->attack_iv = 0xF;\npPartyMember->defense_iv = 0xF;\npPartyMember->speed_iv = 0xF;\npPartyMember->special_iv = 0xF;\n\npPartyMember->move1_pp = 20;\npPartyMember->move2_pp = 15;\npPartyMember->move3_pp = 10;\npPartyMember->move4_pp = 15;\n\npPartyMember->attack = 100;\npPartyMember->defense = 100;\npPartyMember->speed = 100;\npPartyMember->special = 100;\n```\n\nand deserialized like so:\n\n```c\nvoid party_member_to_bytes(struct PartyMember *pPartyMember, uint8_t *out) {\n    uint8_t res[44] = {\n        pPartyMember->pokemon,\n        (uint8_t) (pPartyMember->current_hp >> 8),\n        (uint8_t) (pPartyMember->current_hp & 0x00FF),\n        pPartyMember->level,\n        pPartyMember->status,\n        pPartyMember->type1,\n        pPartyMember->type2,\n        pPartyMember->catch_rate_or_held_item,\n        pPartyMember->move1,\n        pPartyMember->move2,\n        pPartyMember->move3,\n        pPartyMember->move4,\n        (uint8_t) (pPartyMember->original_trainer_id >> 8),\n        (uint8_t) (pPartyMember->original_trainer_id & 0x00FF),\n        (uint8_t) ((pPartyMember->experience & 0x00FF0000) >> 16),\n        (uint8_t) ((pPartyMember->experience & 0x0000FF00) >> 8),\n        (uint8_t) (pPartyMember->experience & 0x000000FF),\n        (uint8_t) (pPartyMember->HP_ev >> 8),\n        (uint8_t) (pPartyMember->HP_ev & 0x00FF),\n        (uint8_t) (pPartyMember->attack_ev >> 8),\n        (uint8_t) (pPartyMember->attack_ev & 0x00FF),\n        (uint8_t) (pPartyMember->defense_ev >> 8),\n        (uint8_t) (pPartyMember->defense_ev & 0x00FF),\n        (uint8_t) (pPartyMember->speed_ev >> 8),\n        (uint8_t) (pPartyMember->speed_ev & 0x00FF),\n        (uint8_t) (pPartyMember->special_ev >> 8),\n        (uint8_t) (pPartyMember->special_ev & 0x00FF),\n        (uint8_t) (((pPartyMember->attack_iv & 0xF) << 4) | (pPartyMember->defense_iv & 0xF)),\n        (uint8_t) (((pPartyMember->speed_iv & 0xF) << 4) | (pPartyMember->special_iv & 0xF)),\n        pPartyMember->move1_pp,\n        pPartyMember->move2_pp,\n        pPartyMember->move3_pp,\n        pPartyMember->move4_pp,\n        pPartyMember->level,\n        (uint8_t) (pPartyMember->max_hp >> 8),\n        (uint8_t) (pPartyMember->max_hp & 0x00FF),\n        (uint8_t) (pPartyMember->attack >> 8),\n        (uint8_t) (pPartyMember->attack & 0x00FF),\n        (uint8_t) (pPartyMember->defense >> 8),\n        (uint8_t) (pPartyMember->defense & 0x00FF),\n        (uint8_t) (pPartyMember->speed >> 8),\n        (uint8_t) (pPartyMember->speed & 0x00FF),\n        (uint8_t) (pPartyMember->special >> 8),\n        (uint8_t) (pPartyMember->special & 0x00FF),\n    };\n    for (size_t i = 0; i < 44; i++) {\n        out[i] = res[i];\n    }\n}\n```\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegqyx2m\n\nMakes sense, right? Copying from SRAM / RAM is always going to be cheaper than restructuring data. I guess I should have guessed that.\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegqyy2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegrya2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryb2m\n\nI just skipped over SO MUCH. I must've been tired when I wrote this BSky post, because it skips a major part of the protocol.\n\nSo, that `handle_byte` function I've been talking about before we derailed, it manages the state of the connection. We left off on this part:\n\n```c\ncase PKMN_TRADE_CENTER: // 0xD4\n    // No byte response known; just move on the next case (we'll discuss later)\n    connection_state = TRADE_CENTER; // enum holding the state of the connection\n    break;\n```\n\nYou may notice that it doesn't send a byte back to the master. It instead moves on to the next case, which is the `TRADE_CENTER` state. Instead of breaking down the code segments, which are long and illegible, I will explain the logic of the process.\n\n- When in doubt, echo back the input to the output\n    - If things get really bad, start the process over from the beginning\n- The Trade Center status is in its default state, `INIT`\n    - In this case, we are waiting for a `0x00` byte from the master\n    - We respond with `0x00` and move to the next state, `READY`\n- The TC status is in the `READY` state\n    - In this case, we are waiting for a `0xFD` byte from the master\n    - We respond with `0xFD` and move to the next state, `AGREED`\n- The TC status is in the `AGREED` state\n    - In this case, we are waiting for any byte that is ***NOT*** `0xFD` from the master\n    - We respond with `0xFD` and move to the next state, `ANY_IN`\n- The TC status is in the `ANY_IN` state\n    - ***We set a counter to 0 to count the number of bytes we receive***\n    - In this case, we are waiting for any byte from the master\n    - We respond with `0xFD` and move to the next state, `WAIT`\n- The TC status is in the `WAIT` state\n    - If we receive a `0xFD` byte\n        - ... we just respond with a `0x00` until we get a different response\n    - If we receive a byte that is ***NOT*** `0xFD` \n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n        - ***We set a counter to 0 to count the number of bytes we receive***\n        - We respond with the first byte of our TraderPacket we constructed from the struct earlier\n        - We add 1 to the counter\n        - We move to the next state, `TRANSFER`\n- The TC status is in the `TRANSFER` state\n    - In this case, we are waiting for any byte from the master\n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n    - We respond with the next byte of our TraderPacket we constructed from the struct earlier\n    - We add 1 to the counter\n    - If we have sent all 418 bytes, we move to the next state, `PATCH`\n        - Why 418? That's the size of the TraderPacket struct when we deserialized it\n- The TC status is in the `PATCH` state\n    - If we receive a `0xFD` byte from the master\n        - ***We set a counter to 0 to count the number of bytes we receive***\n        - We respond with `0xFD`\n    - If we receive a byte that is ***NOT*** `0xFD`\n        - NOTE: We'll be throwing the byte we receive away, but you can keep it if you care about the packet the master is sending us\n        - We respond by echoing back whatever the master sends us\n        - We add 1 to the counter\n        - If we have sent 197 bytes, we move to the next state, `TRADE_WAIT`\n            - Why 197? Because that's how long the trade animation is, and this is just to see if we're still alive\n- The TC status is in the `TRADE_WAIT` state\n    - If we receive a byte that is `&` with `0x60` to equal `0x60`\n        - If we receive a `0x6f`, we respond with `0x6f` and move back to the `READY` state to start over\n        - If we receive a `0x60`, we respond with `0x60` and move to the next state, `TRADE_DONE`\n    - If we receive a `0x00` byte from the master\n        - We respond with `0x00`\n        - We move to the next state, `TRADE_DONE`\n- The TC status is in the `TRADE_DONE` state\n    - We are waiting for a byte from the master that can be `&` with `0x60` to equal `0x60`\n        - We always echo back this byte. We are just reading it to see what the status of the trade is\n        - If the byte is `0x61`, we go back to `TRADE_WAIT`\n        - Otherwise, we're `DONE`\n- The TC status is in the `DONE` state\n    - We are waiting for `0x00` from the master\n        - We respond with `0x00`\n        - We move back to the `INIT` state to start over\n\nHere are all the states and what they do:\n\n- `INIT`: Trade has started\n- `READY`: Both devices are ready to begin\n- `AGREED`: Both devices have agreed where to start\n- `ANY_IN`: Waiting for the master to send us data\n- `WAIT`: Waiting for the master to send us data\n- `TRANSFER`: Sending the TraderPacket to the master\n- `PATCH`: Waiting for the animation to finish\n- `TRADE_WAIT`: Waiting for the trade to finish\n- `TRADE_DONE`: Trade is done\n- `DONE`: Connection is done\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryc2m\n\nSomewhat in correct, please refer to my above correction\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegryd2m\n\nSomewhat in correct, please refer to my above correction\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdegtwt2m\n\nhttps://bsky.app/profile/bread.codes/post/3lcrkdermo32m\n\nOver a year ago, I was working on a YouTube video where I would explain how to counterfeit Pokemon through the trade protocol. Unfortunately, life happens, and I never got to share this the way I wanted to. You can follow @BreadCodes on YouTube if you want to see that kind of content!","categories":["pokemon","gameboy","game boy","retro-computing"],"skeets":[]},{"title":"Fact Check Movies While Watching","date":"2024-10-16","slug":"fact-check-movies-while-watching","excerpt":"Have you ever watched a \"Based on a True Story\" movie and wondered how much of it was true? Have you ever paused a movie to see how much of it actually happened? Have you heard that American Sniper was mostly fabricated and wanted to know which parts?","content":"Have you ever watched a \"Based on a True Story\" movie and wondered how much of it was true? Have you ever paused a movie to see how much of it actually happened? Have you heard that American Sniper was mostly fabricated and wanted to know which parts?\n\nAll of those apply to me, and aparently to David McCandless, Dr Stephanie Starling, Omid Kashan, and Karl Webster. They created a [Visualisation of the accuracy of movies \"based on a true story\"](https://informationisbeautiful.net/visualizations/based-on-a-true-true-story/). \n\nI felt inspired by their work, and I had an idea: What if we could see fact checking information while watching a movie?... Maybe a bit boring and intrusive to some, but I think this would be a fun feature for those who are interested in the truth behind the stories.\n\nBelow are the SRT files for the movies that have been fact checked by the great people I meantioned. I wrote a script to compile into subtitles to be used while watching a movie, and while this post isn't what I have this site for, I thought I'd share the result of a short project instead of the whole process. \n\n## Download the subtitles:\n\nThese subtitles are listed in alphabetical order. You can use these files with your favourite media player that supports SRT files, such as Plex, VLC, Kodi, etc.\n\n- [12 Years a Slave](/assets/factchecksrt/12_years_a_slave.srt)\n- [American Sniper](/assets/factchecksrt/american_sniper.srt)\n- [Bohemian Rhapsody](/assets/factchecksrt/bohemian_rhapsody.srt)\n- [Bridge of Spies](/assets/factchecksrt/bridge_of_spies.srt)\n- [Captain Phillips](/assets/factchecksrt/captain_phillips.srt)\n- [Dallas Buyers Club](/assets/factchecksrt/dallas_buyers_club.srt)\n- [Hacksaw Ridge](/assets/factchecksrt/hacksaw_ridge.srt)\n- [Hidden Figures](/assets/factchecksrt/hidden_figures.srt)\n- [Lion](/assets/factchecksrt/lion.srt)\n- [Philomena](/assets/factchecksrt/philomena.srt)\n- [Rush](/assets/factchecksrt/rush.srt)\n- [Selma](/assets/factchecksrt/selma.srt)\n- [Spotlight](/assets/factchecksrt/spotlight.srt)\n- [The Big Short](/assets/factchecksrt/the_big_short.srt)\n- [The Imitation Game](/assets/factchecksrt/the_imitation_game.srt)\n- [The King's Speech](/assets/factchecksrt/the_kings_speech.srt)\n- [The Social Network](/assets/factchecksrt/the_social_network.srt)\n- [The Wolf of Wall Street](/assets/factchecksrt/the_wolf_of_wall_street.srt)\n\n## I like this idea, can I submit a movie?\n\nSure! Email me at [brad@bread.codes](mailto:brad@bread.codes) and I'll send you a tempalte to fill out for your favorite movie, then once you send it back, I'll add it to the list above and credit you and your amazing work. Please include \"Fact Check Movie\" in the subject line!\n\n## Uh Oh, something's wrong with the subtitles, and it's not just my media player!\n\nIf you find an issue with the subtitles like misaligned text, please email me at [brad@bread.codes](mailto:brad@bread.codes) and I'll fix it as soon as possible. Please include \"Fact Check Movie\" in the subject line!\n\n## How to use the subtitles:\n\n1. Download the SRT file for the movie you want to watch.\n2. Open your movie in your favourite media player on your computer (or TV/phone/tablet if you are using Plex, VLC, Kodi).\n3. Load the SRT file while the movie is open if you are using VLC. If you are using Plex, you can include the subtitle in the same directory as the movie file, and Plex may automatically load it for you, if not you can choose it in the captions menu.\n4. Enjoy the movie with fact checking information!\n\n## Original Data Credits:\n\nAgain, thank you so much to David McCandless, Dr Stephanie Starling, Omid Kashan, and Karl Webster for their amazing work. You can find their original visualization [here](https://informationisbeautiful.net/visualizations/based-on-a-true-true-story/).\n\nYou can also see their roles and more of their work here:\n\n- Concept & Design: [David McCandless](http://davidmccandless.com)\n- Code & Design: [Omid Kashan](https://omid.uk)\n- Research: [Dr Stephanie Starling](https://stephaniestarling.com), Karl Webster\n- [See the data](https://docs.google.com/spreadsheets/d/1sJDpzYH_sMYuYHqkmZeJGIq_TEXGDjboYdSoew7UjZ8)\n- [Information is Beautiful](https://informationisbeautiful.net/)","categories":["miniproject","media"],"skeets":[]}]},"__N_SSG":true}