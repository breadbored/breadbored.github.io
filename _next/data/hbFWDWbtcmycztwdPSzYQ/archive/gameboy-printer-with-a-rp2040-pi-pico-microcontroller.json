{"pageProps":{"post":{"title":"Gameboy Printer with a RP2040 (Pi Pico) Microcontroller","date":"2022-12-01","slug":"gameboy-printer-with-a-rp2040-pi-pico-microcontroller","excerpt":"## Table of Contents","content":"## Table of Contents\n\n1. [The Project](#the-project)\n2. [The Serial Protocol](#the-serial-protocol)\n   1. [Definitions](#definitions)\n   2. [Diagrams](#diagrams)\n   3. [Pseudocode](#pseudocode)\n3. [The Gameboy Printer](#the-gameboy-printer)\n4. [Important Notes](#important-notes)\n\n<iframe width=\"536\" height=\"301\" src=\"https://www.youtube.com/embed/EhVYzfLQQ70\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n\n<a href=\"https://www.patreon.com/bePatron?u=34519148\" data-patreon-widget-type=\"become-patron-button\">Become a Patron!</a><script async src=\"https://c6.patreon.com/becomePatronButton.bundle.js\"></script>\n\n## The Project\n\nThe objective is to document the Gameboy Printer, it's protocol, and the image format in a single source, and use that information to create a printer driver using a Raspberry Pi Pico.\n\nI originally did this project on the Arduino back in 2014 using a project that was already available, but I'm writing all of this from the ground up to better document, integrate into other Gameboy related projects, and of course bring the Gameboy Printer to the Pi family. The project I originally used was [davedarko/GBPrinter](https://github.com/davedarko/GBPrinter) that generated PHP page to handle generating some of the code, but more recently I found that someone forked that project to bring us the improved [octavifs/GBPrinter](https://github.com/octavifs/GBPrinter) that uses Go for generating images.\n\nThe Raspberry Pi company have now released a $4 ARM microcontroller, and I wanted this to be as cheap as possible for other people to try.\n\n## The Serial Protocol\n\nThe Gameboy Original/Color/Advance, and by extension the Gameboy Printer, use an SPI-esque protocol to talk to each other. SPI is avery simple synchronous protocol, involving only a TX (outbound data), RX (inbound data), CLK (clock), and the CS (chip select) which the gameboy does not use. The Gameboy excludes the CS pin as it only expects to have a single master device and a single slave device.\n\n### Definitions\n\n- Master\n  - The primary device that manages the interaction\n- Slave\n  - The device being controlled by the master\n- CLK\n  - Clock\n  - A signal that goes `HIGH` then `LOW` to let the slave know that the next piece of data is coming\n- TX\n  - Digital signal out from the master or slave device. Connects to the other device's RX.\n- RX\n  - Digital signal in to the master or slave device. Connects to the other device's TX.\n- CS\n  - Chip Select (unused)\n- GND\n  - Ground\n\n### Diagrams\n\nBelow is the Gameboy Color Cable pinout.\n\n```text\n    _________   1 -> 5v*\n   / 1  2  3 \\  2 -> RX\n  /           \\ 3 -> CLK\n  |           | 4 -> TX\n  |  4  5  6  | 5 -> Reserved*\n  +-----------+ 6 -> GND\n\n* means we do not need that pin\n```\n\nIt is important to test these pins with a voltmeter because the inner cable colors are rarely correctly colored on 3rd party cables, and sources that rely on color coded wires may cause damage to your microcontroller. When you use a voltmeter to identify the TX and RX pins, remember that the TX from one end is the RX for the other and vice versa. Below will hopefully clarify what I am saying:\n\n```text\n  Master        Slave\n  | TX ___   ___ TX |\n  |        \\/       |\n  |        /\\       |\n  | RX ---   --- RX |\n```\n\nEach clock cycle (HIGH/LOW or 1/0) only one bit of data is transferred. Data is sent and read on the rising edge of the clock; rising edge meaning the short ±1 microsecond when the clock goes from LOW to HIGH. The following is an ASCII diagram from the oscilloscope where the number `162` (`0xA2` in hex or `10100010` in binary). The Gameboy has a clock speed of 8192 bits per second (8kb/s), which is 1KB/s or 1 bit every ~122μs.\n\nBoth the master and slave can send and receive data at the same time. Once 8 bits have been sent/received they are processed as a byte.\n\n```\nClock: ^ denotes rising edge, * denotes falling edge\nTX: sending `10100010` in binary (`0xA2` in hex)\nRX: receiving `0b11001100` in binary (`0xCC` in hex)\n\n                       ┏━━━━━━━━┓\n    ┏━━━━━━━━━━━━━━━━━━┛ 1 byte ┗━━━━━━━━━━━━━━━━━━┓\n       __    __    __    __    __    __    __    __\nCLK __/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\__/  \\\n      ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *  ^  *\n       __          __                      __\nTX  __/  \\________/  \\____________________/  \\______\n      1     0     1     0     0     0     1     0\n       __    __                __    __\nRX  __/  \\__/  \\______________/  \\__/  \\____________\n      1     1     0     0     1     1     0     0\n```\n\n### Pseudocode\n\nGenerally, the master would look like this pseudocode where it drives the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\n// 1 is HIGH, 0 is LOW\nstate clock_state = 1;\n\nint clock_speed = 8192;\n\nwhile (data_bit_position < 8) {\n  // Flip the state to what we're about to process\n  clock_state = clock_state == 1 ? 0 : 1;\n  // Send the clock state to the Gameboy Printer cable\n  set_clock(clock_state);\n\n  // Send data on rising edge\n  if (clock_state == 1) {\n    // Send data\n    state bit_to_send = (data_to_send >> data_bit_position) & 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() << data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n\n  // 1,000,000μs in a second\n  // Wait 1,000,000/clock_speed in microseconds to match the clock speed\n  // Divide it by 2 so that the rising edge and falling edge take place within one cycle period\n  sleep_us(1000000 / clock_speed / 2);\n}\n```\n\nAnd generally, the slave would look like this pseudocode where it waits for a state change from the clock:\n\n```\nbyte data_to_send = 0xA2;\nbyte data_receiving = 0x00;\n\n// Used for bit-shifting data\nint data_bit_position = 0;\n\nstate last_clock_state = 1;\n\nwhile (data_bit_position < 8) {\n  state current_clock_state = get_clock();\n\n  // Send data on rising edge\n  if (current_clock_state == 1 && current_clock_state !== last_clock_state) {\n    last_clock_state = current_clock_state;\n\n    // Send data\n    state bit_to_send = (data_to_send >> data_bit_position) & 0b00000001; // Results in  1 or 0\n    set_tx(bit_to_send);\n\n    // Receive Data\n    data_receiving = (get_rx() << data_bit_position) | data_receiving;\n\n    // Set the position for the next bit\n    if (++data_bit_position == 8) {\n      // Reset to read and send the next byte\n      data_bit_position = 0;\n      data_receiving = 0x00;\n    }\n  }\n}\n```\n\nThat pseudocode should give you an idea about what we're working with here.\n\n### The Gameboy Printer\n\nHere's the thing, this is where it gets complicated. I'll try to break it down.\n\n#### Master to Slave\n\nMaster TX to Slave RX is described below\n\n##### Magic Bytes (2)\n\nThis is the simplest part of the protocol. It never changes. The first byte the master sends is always `0x88` and the second byte is always `0x33`. All this does is tell the printer we are here and that we are about to send something it needs to listen to. That's all!\n\n##### Command Byte (1)\n\nThis tells the printer what we want to do.\n\n### Important Notes\n\n#### Voltage Warnings\n\nThe Pico is not 5v tolerant and can only send and receive 3.3v. **_Do not hook the Pico directly to the Gameboy Printer._** There is a risk that a 5v signal to the Pico's serial pins will release [the magic smoke](https://en.wikipedia.org/wiki/Magic_smoke). The pi doesn't have any big capacitors so no smoke will be seen, but I think it is a lot scarier when it just silently dies and you don't know why.\n\nThe Gameboy Printer can only send and receive 5v, and won't read data from the 3.3v Pico as it doesn't seem to reach the minimum `HIGH` threshold the GBP is trying to read. This doesn't damage anything, but it's a major bummer.\n\nYou will need a 3.3v to 5v logic level shifter to safely transmit and receive data, which will avoid both of these issues.","categories":["retro-computing","microcontrollers"],"skeets":[]}},"__N_SSG":true}