{"pageProps":{"post":{"title":"Proprietary Wireless L3 Protocol From Packet Traces","date":"2022-03-09","slug":"proprietary-wireless-l3-protocol-from-packet-traces","excerpt":"## Please Note","content":"## Please Note\n\nThis is not my work, but I am hosting it here for archival purposes. The source I am rehosting is [here](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WMBProtocol), which is a archival rehost of a a website no longer hosting the content, a website which is rehosting parts of a paper from 2005 by the same author entitled _Inferring a Proprietary Wireless L3 Protocol From Packet Traces_.\n\nThis came up in my research for the NDS Download Play protocol and it appears that the only place hosting this content is the WaybackMachine. I am hosting it here for archival purposes. If you are the original author and wish for me to take it down, please contact me at [brad@bread.codes](mailto:brad@bread.codes).\n\n## Archived Content:\n\nOriginal Note from `bottledlight.com`: This is a reformatted version of the technical content from _Inferring a Proprietary Wireless L3 Protocol From Packet Traces_ paper, and should probably be split up / otherwise wikified at some point. The ... represents a bit of the original paper that was cut.\n\nThere was also an associated [presentation](https://web.archive.org/web/20110723013725/http://www.cs.unc.edu/~jasleen/Courses/Fall05/projects/wmb_presentation.pdf) to go with the paper.\n\n....\n\nSee [Wireless Basics](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WirelessBasics) for more 802.11 frame information.\n\n# Available Game Advertisement\n\nWMB uses beacon frames to advertise available games for download. The beacon frames are normally used to advertise available access points in most 802.11 systems, but there is nothing preventing their use in this capacity. The advertisement data is fragmented and stored partially in each [beacon frame](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Wifi/WirelessBasics) as the payload of a custom information element (tag: 0xDD).\n\nThe DS Download Play menu only lists games when the beacons are broadcasted on one of the following channels: 1, 3, 4, 5, 7, 9, 10, 11, 13, and 14. However, the DS hosting mechanism only seems to transmit on channels 1, 7, and 13 (apparently selected at random).\n\nAll beacon frames transmitted by a DS host have the following format:\n\n|     |\n| --- |\n| 802.11 management frame |\n| 802.11 beacon header |\n| Supported rates (tagged IE, advertises 1 Mbit and 2 Mbit) |\n| DS parameter set (tagged IE, note: Distribution System, not Nintendo DS) |\n| TIM vector (tagged IE, transmitted as empty) |\n| Custom extension (tagged IE, tag `0xDD`) |\n\nNintendo specific beacon fragment format (information element code 0xDD):\n\n| Offset | Description |\n| --- | --- |\n| `0x00` | Manufacturer (`00 09 BF`) |\n| `0x03` | `00` |\n| `0x04` | `0A 00 00 00` |\n| `0x08` | `01 00 40 00` |\n| `0x0C` | `24 00 40 00` |\n| `0x10` | Randomly generated stream code |\n| `0x12` | `70 0B` |\n| `0x14` | `00 01 08 00` |\n| `0x18` | `24 00 40 00` (varies from game to game) |\n| `0x1C` | End of advertisement flag (`00` for non-end, `02` for end packets) |\n| `0x1D` | Always `00`, `01`, `02`, or `04` |\n| `0x1E` | Number of players already connected |\n| `0x1F` | Sequence number (0 .. total\\_advertisement\\_length) |\n| `0x20` | Checksum (2 byte little-endian) |\n| `0x22` | Sequence number in non-final packet, # of players in final packet |\n| `0x23` | Total advertisement length – 1 (in beacons) |\n| `0x24` | Payload size in bytes (2 byte little-endian) |\n| `0x26` | Payload begins |\n\nThe checksum is a custom algorithm, I have included example source in the appendix.\n\nThe advertisement fragments are reordered and assembled according to their internal sequence number, to form the overall advertisement payload, as defined below:\n\n| Offset | Size | Description |\n| --- | --- | --- |\n| `0x000` | 32  | Icon palette (16 RGB555 entries) |\n| `0x020` | 512 | Icon tiles (4x4 8x8 4 bit palletized tiles) |\n| `0x220` | 1   | Unknown (0x0B) |\n| `0x221` | 1   | Length of hosting name |\n| `0x222` | 20  | Name of hosting DS (10 UCS-2) |\n| `0x236` | 1   | Max number of players |\n| `0x237` | 1   | Unknown (0x00) |\n| `0x238` | 96  | Game name (48 UCS-2) |\n| `0x298` | 192 | Game description (96 UCS-2) |\n| `0x358` | 64  | 00’s if no users are connected |\n| `0x398` | 0   | End of data if no users are connected |\n\nThe game name and game description are parsed out of the 128 characters stored in the .NDS file banner area. The game name comes from the first line of the banner, and the remaining lines go into the description. No WMB downloads have been observed that had more than 128 characters for these two fields combined, but it should be possible.\n\nThe icon format is a standard DS graphics format, constructing the 32x32 icon out of 8x8 pixel tiles, where each pixel is a 4-bit index into a 16-color palette. The 0th palette index is designated as transparent, allowing the background to show through. This also comes from the banner area of the original NDS file.\n\n# Authentication process\n\nOnce a user B chooses a download offered by a host A, the following standard 802.11 authentication process observed.\n\n1.  Host A advertises a game in beacon frames as described above\n2.  Client B sends an authentication request (sequence 1) to A\n3.  Host A replies with an ACK\n4.  Host A sends an authentication reply (sequence 2) to B\n5.  Client B replies with an association request\n6.  Host A replies with an ACK\n7.  Host A sends an association response\n8.  Client B responds with an ACK\n\nAfter this, the two are associated, and will remain so until the transfer is complete or one is idle for several seconds, at which point they will de-associate. For more information on the association process, see the 802.11 standard.\n\n# Download process\n\nAfter authentication:\n\n1.  Host sends Pings (type 0x01, replies are 0x00, 0x07)\n2.  Host sends RSA frame (type 0x03, replies 0x08)\n3.  Host sends NDS header (type 0x04, replies 0x09)\n4.  Host sends ARM9 binary (type 0x04, replies 0x09)\n5.  Host sends ARM7 binary (type 0x04, replies 0x09)\n6.  Host terminates transfer (type 0x05, no replies)\n\nThe WMB protocol ostensibly implements layers 3 to 7 of the OSI network model, but does not define a new type of network addresses. However, it does define a couple of special broadcast-like MAC addresses within the assigned Nintendo namespace (`00:09:BF`).\n\nThe three channels or flows used for all communications after the MAC broadcast beacons take the form `03:09:BF:00:00:xx`, where xx is:\n\n*   00 for the main data flow, from host to client\n*   10 for the client to host replies\n*   03 for the feedback flow, host to client (acknowledges the replies)\n\nObserved commands:\n\n| Command | Description |\n| --- | --- |\n| 0x01 | Ping / Name request |\n| 0x03 | RSA signature frame |\n| 0x04 | Data packet |\n| 0x05 | Post-idle / unknown |\n\nObserved replies\n\n| Reply ID | Description |\n| --- | --- |\n| 0x00 | Pong (ping reply) |\n| 0x07 | Name reply |\n| 0x08 | RSA frame reply |\n| 0x09 | Data packet reply |\n\nThe host does something unusual with the 802.11 sequence control field, each packet sent out on the 00 flow has a sequence control number 2 greater than the previous one, even if they are sent sequentially. When the host acknowledges a reply (on flow 03) from the client about a particular packet, it uses the sequence number one after the original packet number it sent out on 00. This is the root of one of the major problems in finding a PC card that can transmit WMB packets, as very few cards provide user control over it. Even when a card is capable of ‘raw’ 802.11 transmission, it typically takes care of the sequence control field in hardware or firmware, filling it with a constantly incrementing number.\n\n# Host-to-client packets (on the 0x00 flow)\n\n| 0   | 1   | 2   | 3   | 4   | 5   | 6..e-3 | e-2 | e-1 | e-0 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 06  | 01  | 02  | 00  | Size | Flags | Payload | 00  | 02  | 00  |\n\nNotes:\n\n*   The size field is in terms of half-words (16 bits), and includes the flags byte along with the payload (so a size of 0x03 represents a flag byte, a command byte, and 4 bytes of payload).\n*   When flags is 0x11, the first byte of the payload is a command. There seems to be no important data when flags is not 0x11 (seen occasionally as 0x01), and ignoring them still results in a complete dump.\n\nThe Ping messages (type 0x00) have a payload size of 0x03, but always contain zeroes in the payload. They seem to be used only to keep the connection alive while waiting for the host DS to start the transfer, to prevent a time-out de-association.\n\nThe RSA frame format (type 0x03) sends a table of information about the game being downloaded (most of it redundant with the NDS header, see Appendix), as well as the RSA signature for the DS. I have not looked into computing the signature, as homebrew developers are not privy to Nintendo’s private key, making signing a fruitless activity, but it is my understanding that the signature is a 128 byte public key and an 8 byte SHA-1 message digest over the NDS header, ARM9 binary, and ARM7 binary. Notably: the RSA frame itself is not included as part of the data being signed, bringing up various security issues and making Nintendo’s firmware engineers look amateurish at best.\n\nThere are several abortive sendings of empty RSA frames with a size field of 0x03, before the real frame is sent (always with a size field of 0x75).\n\n|     |     |     |\n| --- | --- | --- |RSA signature frame payload (type 0x03)\n| Offset | Size | Description |\n| `0x00` | `4` | ARM9 execute address |\n| `0x04` | `4` | ARM7 execute address |\n| `0x08` | `4` | `0x00` |\n| `0x0C` | `4` | Header destination |\n| `0x10` | `4` | Header destination |\n| `0x14` | `4` | Header size (0x160) |\n| `0x18` | `4` | `0x00` |\n| `0x1C` | `4` | ARM9 destination address |\n| `0x20` | `4` | ARM9 destination address |\n| `0x24` | `4` | ARM9 binary size |\n| `0x28` | `4` | `0x00` |\n| `0x2C` | `4` | `0x022C0000` |\n| `0x30` | `4` | ARM7 destination address |\n| `0x34` | `4` | ARM7 binary size |\n| `0x38` | `4` | `0x01` |\n| `0x3C` | `136` | Signature block |\n| `0xC4` | `36` | `0x00`’s |\n| `0xE8` | `0` | End of frame payload |\n\nNotes:\n\n*   The offsets in the table are from after the command byte, i.e. two bytes into the 234 bytes of payload including the flags.\n*   The unknown address 0x022C0000 is probably ARM7 related, by comparison with the duplicated header and ARM9 destination addresses 32 and 16 bytes before it, although it has no known significance according to the NDS header.\n\nThe data packets (type 0x04) include a transport-layer sequence number inside of the data packet itself, but no destination offset or other mechanism to allow the packets to be processed out-of-order. The only way to place the data at the correct location in memory is to re-order the packets according to the sequence number and process them sequentially.\n\n|     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- |Data packet (type 0x04)\n| 0   | 1   | 2   | 3   | ..  | End |\n| 00  | \\[Sequence #\\] |     | xx  | ..  | yy  |\n\nThe sequence number is a zero based little-endian number. Each packet only contains data for one of the three destination blocks (header, ARM9, ARM7), so the change-of-destination check only needs to be made on packet boundaries.\n\n# Client to Host Replies (on the 0x10 flow)\n\nThe replies from client to host are sent on the 0x10 flow. The client uses an incrementing sequence control number for all of its packets, with no unusual trickery. Each reply is sent as a standard 802.11 data frame (typically as a Data + CF-Acknowledgement), consisting of 10 data bytes for the WMB payload. The first two are always 0x04 0x81, with the third byte indicating the type of reply, and the remaining 7 bytes being reply-specific.\n\nOne type of packet frequently sent before a download gets underway is what I have termed the Idle or Pong packet (in response to 0x00 ‘Pings’). It has a reply type field of 0x00, and does not contribute any additional information.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Idle / Pong reply (type 0x00)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `00` | `00` | `00` | `00` | `00` | `00` | `00` | `00` |\n\nThe name reply (type 0x07) is sent shortly after association is completed, although I am not certain what triggers it. There are a variable number of pings preceding this reply, but most are replied via Pongs. The name reply sends the user-configured DS name (set in the firmware menu) split over four messages (with the 4th byte of the packet specifying which message fragment this is, 1 based). This can be a total length of 10 UCS-2 characters, although all four messages are still sent if it is shorter (padded with nulls to 10 characters, and then 01 and then nulls until the end of the frame).\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Name reply (type 0x07)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `07` | `01` | \\[Character0\\] |     | \\[Character1\\] |     | \\[Character2\\] |     |\n| `04` | `81` | `07` | `02` | \\[Character3\\] |     | \\[Character4\\] |     | \\[Character5\\] |     |\n| `04` | `81` | `07` | `03` | \\[Character6\\] |     | \\[Character7\\] |     | \\[Character8\\] |     |\n| `04` | `81` | `07` | `04` | \\[Character9\\] |     | `01` | `00` | `00` | `00` |\n\nThe RSA frame receipt reply contains no extra information; it only acknowledges receipt of a type 0x03 host packet on the main flow (0x00). Bizarrely, the xx bytes in the table below are not driven to a particular value when replying to an RSA frame, and usually contain the same data as the second (of four) name response frames.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |RSA frame receipt reply (type 0x08)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `08` | `xx` | `xx` | `xx` | `xx` | `xx` | `xx` | `xx` |\n\nThe data packet receipt reply implements is interesting in that it includes both an immediate acknowledgement and something akin to a cumulative acknowledgement. It specifies the transport layer sequence number for both the packet just received, and the highest continuously addressed packet received.\n\n|     |     |     |     |     |     |     |     |     |     |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |Data packet receipt reply (type 0x09)\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |\n| `04` | `81` | `09` | \\[Last packet\\] |     | \\[Best packet\\] |     | `00` | `00` | `00` |\n\nNotes:\n\n*   \\[last packet\\] is the packet number being acknowledged\n*   \\[best packet\\] is the highest continuous packet number seen so far\n*   Packet IDs are little-endian numbers, like other Nintendo provided data.\n\n# Host to client acknowledgements (on the 0x03 flow)\n\nThese packets contain four data bytes, but three are always zero. The first seems to be random, with no connection to the acknowledged data. The actual indication of acknowledgement is the sequence control number of the packet. It is set to be one greater than the sequence control number of the initial host packet (sent on flow 0x00) that the client has just responded to, to indicate that the reply was received.\n\n|     |     |     |     |\n| --- | --- | --- | --- |Host-to-client acknowledgement\n| 0   | 1   | 2   | 3   |\n| `??` | `00` | `00` | `00` |\n\n# Experimental Verification of Protocol\n\nAn experiment was setup to test some assumptions about the protocol and verify that clean working dumps of WMB transfers could be made.\n\n1.  The Peanuts program was run on a laptop placed near to a DS running the game Polarium.\n2.  The Send a Demo option in the Polarium menu was invoked, and Peanuts was checked to make sure both were operating on the same channel.\n3.  Another DS was turned on in a different room, and the hosted Polarium demo was selected in the DS Download Play menu, and the transfer was allowed to complete.\n4.  Peanut wrote out a reassembled .NDS file as well as an annotated trace log.\n5.  The trace log was checked to make sure the reassembly completed.\n6.  The reassembled file was also checked for file integrity with DSgrok.\n7.  The WMB program was invoked with the captured demo, and a DS with unmodified firmware (i.e. will reject a game with even a single modified byte due to the RSA signature) was used to download the demo.\n8.  The demo ran successfully without the characteristic faded logo lockup indicating a failed signature check, indicating that the capture and reassembly process works, at least for this demo.\n\n# Conclusions and Future Work\n\nThe NiFi protocol, simply put, isn’t. Although both PictoChat and the DS Download Play have some similarities indicating that the same people wrote both programs (which seems likely considering they are both part of the same firmware), there is not a common layer 3 / 4 protocol shared between them.\n\nThe Nintendo DS does not appear to violate the letter of the 802.11 standard. However, most cards are not capable of providing application level control of the sequence number, and many card drivers do not even allow non-IP transmission over 802.11, filtering out incoming packets and providing no interface to send outbound ones.\n\nThe RSA signature frame is a curious design decision. They had to send a signature of the binaries across, but the RSA frame also contains duplicated header fields, including execute addresses. Under other circumstances, this would be a trivial waste of space; except that the signature does not cover the RSA frame itself, and it’s fields are preferentially used over the original header! This means that a DS download server can also operate as a software-based passthrough. Arbitrary code cannot be sent, as the binaries are still signed, but execution can be redirected to a flash cartridge in the GBA slot.\n\n... The additional information in the RSA firmware is ignored by newer versions of the [firmware](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/Main/Firmware), completely preventing the WifiMe soft-passthrough. ...\n\nThe passive method of capture currently implemented in Peanut is sufficient when the client DS is sufficiently far away from the host DS to commonly request the same packet several times. By the very nature of wireless systems, packets have a high loss rate, even when the sender (host) and receiver (laptop) are quite close. If even a single packet is completely lost (i.e. the laptop missed it each time it was (re)transmitted to the client), then reassembly is impossible. The client DS gets around this by not acknowledging packets that were dropped, allowing the host to timeout and retransmit. As a passive snooper, we can’t work around this if the client receives the packet and we do not.\n\nMoving to an active capture system, where Peanut pretends to be a client DS will provide flawless captures every time, and could also lead to a program running on the DS, providing WMB style downloads on DS units that do not have FlashMe installed. As most of the machinery associated with being an active client is common to being an active server, hopefully this would also lead to the first homebrew WMB broadcasts from a DS.\n\n...\n\n# Appendix\n\nThe beacon checksum is a custom algorithm, operating over the payload as half-words. Here is an example of how to compute it.\n\n \n// The checksum is computed over halfwords for the last 4 bytes\n// of the ninty beacon header, plus the payload\n// This func takes length in halfwords\nuint16 computeBeaconChecksum(uint16 \\* data, int length) {\n  uint32 sum = 0;\n  for (int j = 0; j < length; j++) sum += \\*data++;\n  sum = (-((sum >> 16) + (sum & 0xFFFF) + 1)) & 0xFFFF;\n  return sum;\n}\n\nThe .NDS format is the standard format for Nintendo DS programs; it originated on original game cards and also appears to a limited extent in WMB binaries. The WMB process only transfers the first 0x160 bytes of the header, the ARM9 binary, and the ARM7 binary (in that order), ignoring the file name and file allocation tables, the overlay data, and some information stored in the banner (the rest is transmitted partially via the beacon advertisement process).\n\n(No point in duplicating NDS header info here, see the [NDS Format](https://web.archive.org/web/20110723013725/http://www.bottledlight.com/ds/index.php/FileFormats/NDSFormat) page instead.)","categories":["nintendo","ds","nds","download play","wireless","protocol","reverse engineering","wmb","nifi","rsa"],"skeets":[]}},"__N_SSG":true}